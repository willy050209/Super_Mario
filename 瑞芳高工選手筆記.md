---
title: 瑞芳高工選手筆記

---

:::success
:::spoiler Table Of Contents
[toc]
:::

#    型態
Visual Basic 所提供的型別都是繼承 Object
| Visual Basic 型別 | 型別結構          | 名義儲存體配置 | 數值範圍                                                      |
|:----------------- | ----------------- | -------------- |:------------------------------------------------------------- |
| 布林值            | Boolean           | 取決於實作平台 | True(-1) 或 False(0)                                                 |
| 位元組            | Byte              | 1byte          | 0 ~ 255                                                       |
| 有號位元組        | SByte              | 1Bbte          | -128 ~ 127 (有號)                                             |
| 字元              | Char              | 2byte          | 0 ~ 65,535(UTF-16)                                            |
| 字串              | String            | 以字串長度而定 | 上限為 2 GB 大約 10 億個字元(UTF-16)                          |
| 短整數            | Short (Int16)     | 2byte          | -32,768 ~ 32,767                                              |
| 無號短整數        | UShort (UInt16)   | 2byte          | 0 ~ 65,535                                                    |
| 整數              | Integer (Int32)   | 4byte          | -2,147,483,648 ~ 2,147,483,647 (有號)                         |
| 無號長整數        | UInteger (UInt32) | 4byte          | 0 ~ 4,294,967,295                                             |
| 長整數            | Long (Int16)      | 8byte          | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (有號) |
| 無號長整數        | ULong (UInt16)    | 8byte          | 0 ~ 18,446,744,073,709,551,615                                  |
| 單精確度浮點數      | Single   | 4byte          | -3.4028235E+38 到 -1.401298E-45  (用於負值)；1.401298E-45 到 3.4028235E+38 (用於正值)                                |
| 雙精確度浮點數      | Double   | 8byte          | -1.79769313486231570E+308 到 -4.94065645841246544E-324  (用於負值)；4.94065645841246544E-324 到 1.79769313486231570E+308 (用於正值)                               |
| 十進位        | 	Decimal    | 16byte          | 0 到 +/-79,228,162,514,264,337,593,543,950,335 (+/-7.9...E+28) (沒有小數點)；0 到 +/-7.9228162514264337593543950335 (小數點右邊有 28 位)；最小非零數字為 +/-0.0000000000000000000000000001 (+/-1E-28)  |
| 日期            | DateTime              | 8byte          | 0001 年 1 月 1 日 0:00:00 (午夜) 到 9999 年 12 月 31 日下午 11:59:59
| 自由型態            | Object              | 視形況改變          | 任何型別都可以儲存在型別 Object 的變數中

> [資料類型摘要](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/language-reference/data-types/)

##    指定常數型態

```vb
"1" string
"1"c char
123s int16
123i int32
123l int64
123d Decimal
123us uint16
123ui uint32
123ul uint64
1.0 double
1.0f single
```

##    不同進制常數

```vb
&h1010 '2進位
&o1010 '8進位
1010 '10進位
&h1010 '16進位
```

##    型態轉換(casting)


| 類型轉換函式        | 功能         |
|:------------------- | ------------ |
| CBool(expression)   | 轉為Boolean  |
| CByte(expression)   | 轉為Byte     |
| CSByte(expression)  | 轉為SByte    |
| CChar(expression)   | 轉為Char     |
| CStr(expression)    | 轉為String   |
| CShort(expression)  | 轉為Short    |
| CUShort(expression) | 轉為UShort   |
| CInt(expression)    | 轉為Integer  |
| CUInt(expression)   | 轉為UInteger |
| CLng(expression)    | 轉為Long     |
| CULng(expression)   | 轉為ULong    |
| CSng(expression)    | 轉為Single   |
| CDbl(expression)    | 轉為Double   |
| CDec(expression)    | 轉為Decimal  |
| CDate(expression)   | 轉為DateTime |
| CObj(expression)    | 轉為Object   |
|CType(expression, typename)|轉為指定型別|

> [類型轉換函式 (Visual Basic)](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/language-reference/functions/type-conversion-functions)

##    Convert 
命名空間:System
組件:mscorlib.dll
繼承 Object

將基底資料類型轉換為其他基底資料類型。

從基底類型轉換:
轉換方法存在，可將每個基底類型轉換成所有其他基底類型。 不過，特定轉換方法的實際呼叫可能會產生五個結果之一，視執行時間基底類型的值和目標基底類型而定。 這五個結果如下：

1.沒有轉換。 當嘗試從型別轉換成本身 (時，會藉由呼叫 Convert.ToInt32(Int32) 類型 Int32 為) 的引數時發生。 在此情況下，方法只會傳回原始類型的實例。

2.無效型態轉換(InvalidCastException)。 當不支援特定轉換時，就會發生這種情況。

3.格式錯誤(FormatException)。 當嘗試將字串值轉換成任何其他基底類型失敗時，就會發生這種情況，因為字串的格式不正確。

4.成功轉換。 針對先前結果中未列出的兩種不同基底類型之間的轉換，所有擴輾轉換以及所有不會導致資料遺失的縮小轉換都會成功，而且方法會傳回目標基底類型的值。

5.溢位(OverflowException)。 當縮小轉換導致資料遺失時，就會發生這種情況。

非十進位數:
類別 Convert 包含靜態方法，您可以呼叫 將整數值轉換成非十進位字串標記法，以及將代表非十進位數的字串轉換成整數值。 這些轉換方法都包含一個 base 引數，可讓您指定數字系統;二進位 (基底 2) 、八進位 (基底 8) ，以及十六進位 (基底 16) ，以及十進位 (基底 10) 。 有一組方法可將每個符合 CLS 標準的基本整數型別轉換成字串，一個將字串轉換成每個基本整數類型：

ToString(Byte, Int32) 和 ToByte(String, Int32) ，表示將位元組值轉換成指定基底中的字串，以及從字串轉換。

ToString(Int16, Int32) 和 ToInt16(String, Int32) ，將 16 位帶正負號的整數轉換成指定基底中的字串和字串。

ToString(Int32, Int32) 和 ToInt32(String, Int32) ，表示將 32 位帶正負號的整數與指定基底中的字串進行轉換。

ToString(Int64, Int32) 和 ToInt64(String, Int32) ，表示將 64 位帶正負號的整數與指定基底中的字串進行轉換。

ToSByte(String, Int32)，將指定格式的位元組值字串表示轉換成帶正負號的位元組。

ToUInt16(String, Int32)，將指定格式的整數位符串表示轉換成不帶正負號的 16 位整數。

ToUInt32(String, Int32)，將指定格式的整數位符串表示轉換成不帶正負號的 32 位整數。

ToUInt64(String, Int32)，將指定格式的整數位符串表示轉換成不帶正負號的 64 位整數。

從自訂物件轉換為基底類型:
除了支援基底類型之間的轉換之外， Convert 方法還支援將任何自訂類型轉換成任何基底類型。 若要這樣做，自訂類型必須實 IConvertible 作 介面，以定義將實作型別轉換為每個基底型別的方法。 特定類型不支援的轉換應該擲回 InvalidCastException 。

ChangeType當方法傳遞自訂型別做為其第一個參數時，或呼叫 Convert.To Type Convert.ToDouble(Object, IFormatProvider)方法 (， Convert.ToInt32(Object) 並傳遞自訂類型的實例做為其第一個參數時， Convert 方法接著會呼叫自訂類型的 IConvertible 實作來執行轉換。



| 函數                     | 功能                                               |
| ------------------------ | -------------------------------------------------- |
| ToBoolean(Object)        | 將指定之物件的值轉換為相等的布林值。               |
| ToByte(Object)           | 將指定之物件的值轉換為 8 位元不帶正負號的整數。    |
| ToSByte(Object)          | 將指定之物件的值，轉換為 8 位元帶正負號的整數。    |
| ToChar(Object)           | 將指定之物件的值轉換為 Unicode 字元。              |
| ToString(Object)         | 將指定之物件的值轉換為它的相等字串表示。           |
| ToInt16(Object)          | 將指定之物件的值，轉換為 16 位元帶正負號的整數。   |
| ToUInt16(Object)         | 將指定之物件的值轉換為 16 位元不帶正負號的整數。   |
| ToInt32(Object)          | 將指定之物件的值，轉換為 32 位元帶正負號的整數。   |
| ToUInt32(Object)         | 將指定之物件的值轉換為 32 位元不帶正負號的整數。   |
| ToInt64(Object)          | 將指定之物件的值，轉換為 64 位元帶正負號的整數。   |
| ToUInt64(Object)         | 將指定之物件的值轉換為 64 位元不帶正負號的整數。   |
| ToSingle(Object)         | 將指定之物件的值，轉換為單精確度浮點數。           |
| ToDouble(Object)         | 將指定之物件的值，轉換為雙精確度浮點數。           |
| ToDecimal(Object)        | 將指定之物件的值，轉換為相等的十進位數字。         |
| ToDateTime(Object)       | 將指定之物件的值轉換為 DateTime 物件。             |
| ChangeType(Object, Type) | 傳回指定之類型的物件，此物件的值與指定的物件相等。 |


> [相關資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.convert?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.Convert)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)

##    BitConverter

與Convert大致相同差別是BitConverter是轉成ByteArray  
barr[0]是最低的8 bit  
VB的Char是16 bit

| 類型    | 位元組轉換        | 從位元組轉換 | 位元組 |
| ------- | ----------------- | ------------ | ------ |
| Boolean | GetBytes(Boolean) | ToBoolean    | 1      |
| Char    | GetBytes(Char)    | ToChar       | ==2==  |
| Int16   | GetBytes(Int16)   | ToInt16      | 2      |
| Int32   | GetBytes(Int32)   | ToInt32      | 4      |
| Int64   | GetBytes(Int64)   | ToInt64      | 8      |
| Single  | GetBytes(Single)  | ToSingle     | 4      |
| Double  | GetBytes(Double)  | ToDouble     | 8      |

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.bitconverter?view=netframework-4.7.2)
# Operator

##    優先順序規則
當運算式包含來自多個類別的運算子時，會根據下列規則進行評估：

* 算術和串連運算子的優先順序如下一節所述，而且全部高於比較、邏輯和位元運算子。
* 所有比較運算子的優先順序會相等，而且全部高於邏輯和位運算子，但低於算術和串連運算子。
* 邏輯和位元運算子的優先順序如下一節所述，而且全部低於算術、串連和比較運算子。
* 優先順序相等的運算子會依出現在運算式中的順序，從左至右進行評估。


| 優先度 | 性質                   | Operator                                            |
| ------ |:---------------------- | --------------------------------------------------- |
|  最高      |                        |     ()                                                |
|      | 算術運算子             | 乘冪 (^)                                            |
|        | 算術運算子             | 正負號(+、-)                                        |
|        | 算術運算子             | 乘法和浮點數除法 (\*、/)                            |
|        | 算術運算子             | 整數除法 (\\)                                        |
|        | 算術運算子             | 模組式算術 (Mod)                                    |
|        | 算術運算子             | 加法和減法 (+、–)                                   |
|        | 串連運算子             | 字串串連 (&)                                        |
|        | 位元運算子             | 算術移位 (<<、>>)                                   |
|        | 比較運算子             | (=、<>、<、<=、>、>=、Is、IsNot、Like、TypeOf...Is) |
|        | 邏輯運算子             | 否定 (Not)                                          |
|        | 邏輯運算子和位元運算子 | 及 (And, AndAlso)                                   |
|        | 邏輯運算子和位元運算子 | 或(Or、OrElse)                                      |
| 最低     | 位元運算子             | Xor                                                 |
##    Operator Statement
宣告運算子符號、運算元與程式碼，以定義類別或結構的運算子程序。

| 可定義的運算子 |
| -------------- |
| 比較運算子     |
| 算數運算子     |
| 位元運算子     |
| 串連運算子     |
| 邏輯運算子     |
###    限制

您只能在Class或Struct中使用 Operator。 這表示運算子的宣告內容 不能是來源檔案、命名空間、模組、介面、程序或區塊。  
所有運算子都必須是 Public Shared。 您不能為任一運算元指定 ByRef、Optional 或 ParamArray。  
您不能使用運算子符號或識別碼來保存傳回值。 您必須使用 Return 陳述式，而且它必須指定值。Return 陳述式可以出現在程式中的任何位置。  
您必須將特定的運算子定義為相應的對組。 如果您定義這類對組的任一個運算子，也必須定義另一個運算子。 相應的對組如下：  
* = 和 <>
* \> 和 <
* \>= 和 <=
* IsTrue 和 IsFalse

某些運算子有其他的資料類型限制，如下所示：  
如果您定義 IsTrue 和 IsFalse 運算子，則它們都必須傳回 Boolean 類型。  
如果您定義 << 和 >> 運算子，則它們都必須為 operand2 的 operandtype 指定 Integer 類型。  
傳回類型不必對應於任一運算元的類型。 例如，比較運算子 (如 = 或 <>) 可以傳回 Boolean，即使兩個運算元都不是 Boolean 也一樣。  
example:
```vb = 
Class MyPoint
    Dim X, Y As Int16 
    Public Shared Operator =(a As MyPoint, b As MyPoint) As Boolean
        Return a.X = b.X AndAlso a.Y = b.Y
    End Operator
    Public Shared Operator <>(a As MyPoint, b As MyPoint) As Boolean 'VB = 與 <> 要同時定義
        Return Not a = b
    End Operator
End Class
```
> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/language-reference/statements/operator-statement)

#    windows form常用元件介紹
##    Label
Label 控制項通常用來提供控制項的描述性文字。 
> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.label?view=windowsdesktop-8.0)

##    TextBox
TextBox透過控件，用戶可以在應用程式中輸入文字。 此控制項具有標準 Windows 文字框控制件中找不到的其他功能，包括多行編輯和密碼字元遮罩。
###    屬性


| 屬性         | 效果                                                      |
| ------------ | --------------------------------------------------------- |
| Multiline    | 取得或設定值，其會表示這是否為多行 TextBox 控制項。       |
| PasswordChar | 取得或設定在單行 TextBox 控制項中用來遮罩密碼字元的字元。 |
| ScrollBars   | 取得或設定在多行 TextBox 控制項中應該顯示的捲軸。         |

> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.textbox?view=windowsdesktop-8.0)

##    PictureBox
通常 PictureBox 用來顯示點陣圖、JPEG、GIF 或 PNG 檔案中的圖形。
| 屬性          | 效果                                                 |
| ------------- | ---------------------------------------------------- |
| Height        | 取得或設定控制項的高度。                             |
| Width         | 取得或設定控制項的寬度。                             |
| Image         | 取得或設定 PictureBox 顯示的影像。                   |
| ImageLocation | 取得或設定要在 PictureBox 中顯示之影像的路徑或 URL。 |
| SizeMode      | 指示如何顯示影像。                                   |
> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.picturebox?view=windowsdesktop-8.0)

##    CheckBox
CheckBox使用 提供用戶選項，例如 true/false 或 yes/no。 控件 CheckBox 可以顯示影像或文字或兩者。
| 屬性          | 效果                                                 |
| ------------- | ---------------------------------------------------- |
|Checked	|取得或設定值，指出 CheckBox 是否在已核取狀態下。|
> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.checkbox?view=windowsdesktop-8.0)

##    CheckedListBox
與CheckBox類似

##    OpenFileDialog
代表通用對話方塊，可讓使用者為要開啟的一個或多個檔案指定檔名。
| 屬性          | 效果                                                 |
| ------------- | ---------------------------------------------------- |
|FileName	|取得或設定字串，此字串包含在檔案對話方塊中選取之檔案的完整路徑。|
|FileNames	|取得陣列，其中針對所選取的每個檔案，各包含一個檔名。|
|Filter	|取得或設定目前的檔名篩選字串，以決定出現在對話方塊中[檔案類型] 方塊的選項。|
|FilterIndex	|取得或設定目前在檔案對話方塊中選取之篩選條件的索引。|
|Multiselect|取得或設定選項，指出 OpenFileDialog 是否允許使用者選取多個檔案。|
|ReadOnlyChecked	|取得或設定值，指出是否已選取 OpenFileDialog 所顯示的唯讀核取方塊。|

> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/microsoft.win32.openfiledialog?view=windowsdesktop-8.0)
###    Filter
用法
```
顯示名稱 | 副檔名 |
```
範例
```
JEPG Image (*.jpg)|*.jpg|All File (*.)
Office Files|*.doc;*.xls;*.ppt
```

> [Filter參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/microsoft.win32.filedialog.filter?view=windowsdesktop-8.0#microsoft-win32-filedialog-filter)

##    SaveFileDialog
開啟並覆寫現有的檔案，或建立新的檔案。
| 屬性          | 效果                                                 |
| ------------- | ---------------------------------------------------- |
|DefaultExt	|取得或設定預設的副檔名。|
|FileName	|取得或設定含有檔案對話方塊中所選取檔名的字串。|
|Filter	|取得或設定目前的檔名篩選字串，以決定出現在對話方塊中 [另存檔案類型]方塊的選項。|

> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.savefiledialog?view=windowsdesktop-8.0)
#    小技巧

##    使用三個引數呼叫 if 運算子

```vb
If( 判斷式, = true 回傳這個, = false 回傳這個 )
```

這可以讓if敘述寫得更優雅，有點類似C語言的?運算子，但使用他並不會讓程式變快，就只是打比較少的字。  
例如我們要計算最大公因數就能一行解。
```vb=
Function gcd(a As integer, b As integer) As integer
    Return If(b = 0, a, gcd(b, a Mod b))
End Function
```
##    字串操作
在VB中的String不能直接修改中間的字元，所以我們必須先把字串轉成字元陣列，操作完之後再轉回字串
```vb=
Dim str = "this is String."
Dim carr = str.ToCharArray()
' do something ...
str = carr
```
## lambda
Lambda 是沒有名稱的函式或副程式，可在委派有效的地方使用。 Lambda 運算式可以是函式或副程式，而且可以是單行或多行。 您可以將值從目前範圍傳遞至 Lambda 運算式。
```vb
Console.WriteLine((Function(num As Integer) num + 1)(5))'ptint 6
```
排序
```vb
Array.Sort(arr, Function(a, b) a > b)
```
多行lambda
```vb
Array.Sort(strarr, Function(a, b)
                       If a.Length = b.Length Then
                           Return a.CompareTo(b)
                       Else
                           Return a.Length < b.Length
                       End If
                   End Function)
```
[reference](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/programming-guide/language-features/procedures/lambda-expressions)
##    Property Statement
宣告屬性的名稱，以及用來儲存及擷取屬性值的屬性程序。  
有點類似C++的Array subscripting operator []  
例  
```vb
Class Array(Of T)
    Private data As T() '儲存資料
    Default Public Property ArraySubscript(index As Integer) As T '() operator
        Get
            Return Me.data(index)
        End Get
        Set(value As T)
            Me.data(index) = value
        End Set
    End Property
End Class
```
> [參考資料](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/language-reference/statements/property-statement?f1url=%3FappId%3DDev17IDEF1%26l%3DEN-US%26k%3Dk(vb.Property)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.7.2)%3Bk(DevLang-VB)%26rd%3Dtrue)
##    畫棋盤
工科賽很多題目會需要畫棋盤所以要把這個練熟，下面提供我的作法。
1. 我會先設定好我的棋盤在圖片方塊上的原點座標x0、y0、我的棋盤是(n*n)及棋盤的長度
2. 畫水平線的時候Y軸不動動X軸。起點座標(x0,(棋盤的長度/棋盤大小)*第n條線+y0)，終點標(x0+棋盤的長度,(棋盤的長度/棋盤大小)*第n條線+y0)
3. 畫鉛直線的時候X軸不動動Y軸。起點座標((棋盤的長度/棋盤大小)*第n條線+x0,y0)，終點標((棋盤的長度/棋盤大小)*第n條線+x0,y0+棋盤的長度)

範例程式
```vb=
Const x0 As Int16 = 50 '左上角座標
Const y0 As Int16 = 25 '左上角座標
Const boardSize As Int16 = (10 - 1) '盤面大小(10*10)
Const boardLenght As UInt16 = 550 '盤面長度
Dim g As Graphics = Graphics.FromImage(PictureBox1.Image)

g.Clear(Color.LightGray) '畫盤面
For i As Int16 = 0 To boardSize
    '水平線
    g.DrawLine(Pens.Black, x0,
           CSng(boardLenght / boardSize * i) + y0, 'DrawLine函數中的點座標必須是單精確浮點數(Single)
           x0 + boardLenght,
           CSng(boardLenght / boardSize * i) + y0)
    '鉛直線
    g.DrawLine(Pens.Black, CSng(boardLenght / boardSize * i + x0), y0, CSng(boardLenght / boardSize * i + x0), y0 + boardLenght)
Next
Me.Refresh()'記得刷新
```

[參考1](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/programming-guide/language-features/procedures/lambda-expressions)
[參考2](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/programming-guide/language-features/procedures/how-to-create-a-lambda-expression)

##    鏈結串列

vb沒有指標，但可以用物件的方式實現鏈結串列，做法如下。
```vb
Class MyLinkListItem(Of T) '讓使用者自訂型態
    Public Back As MyLinkListItem(Of T) '指向上一個位置
    Public [Next] As MyLinkListItem(Of T) '指向下一個位置
    Public Data As T '資料
    Sub New()
        Me.Back = Nothing
        Me.Next = Nothing
        Data = Nothing
    End Sub
    Sub New(ByRef back As MyLinkListItem(Of T), ByRef [next] As MyLinkListItem(Of T), data As T)
        Me.Back = back
        Me.Next = [next]
        Me.Data = data
    End Sub
End Class
```

##    AI工具
雖然比賽不能使用但是在練習時可以用來參考。\
他們產生的程式未必可以使用，大多情形只要不是過於複雜的問題都可以在做細微的修正之後正常執行。\
就算他們產生了一個完全不能用的程式，也沒有關係觀察他的寫法及演算法或許會對你有所幫助。
[ChatGPT](https://chatgpt.com/)\
[Gemini](https://gemini.google.com/app)

#    常用屬性、方法及常數
##    String
命名空間 : System
組件:System.Runtime.dll
繼承 Object

以一連串的 UTF-16 字碼單位表示文字。

> [相關資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.string?view=net-7.0)

###    Length
取得此字串的長度。
回傳int32

### Chars(Int32)
取得此字串的字元
回傳Char
==Read only==

###    Compare(String, String)
比較兩個指定的 String 物件，並傳回一個整數，指出它們在排序順序中的相對位置。
從第一個字元開始比用(Unicode)比較大小

Compare(strA, strB)

參數
strA as String
要比較的第一個字串。

strB as String
要比較的第二個字串。

傳回
Int32
32 位元帶正負號的整數，表示兩個比較元之間的語彙關係。


| 值 | 條件 |
| -------- | -------- |
|<0	|在排序次序中，strA 會排在 strB 之前。
|=0	|strA 出現在排序次序中的位置和 strB 相同。
|>0	|在排序次序中，strA 會排在 strB 之後。
> [unicode 查詢](https://jicheng.tw/hanzi/unicode)


###    Concat(Object, Object)
回傳將其前後引數轉為字串在做串接
可以用+運算子取代


###    Concat(Object())
回傳將其陣列引數轉為字串在做串接


###    IndexOf(Char)
回傳這個字串中指定之 Unicode 字元第一次出現時的所在索引 (以0為起始)，如果找不到為 -1。


###    LastIndexOf(Char)
回傳這個字串中指定之 Unicode 字元最後一次出現時的所在索引 (以0為起始)，如果找不到為 -1。


###    Remove(Int32, Int32)
傳回新字串，其中已刪除在目前執行個體中指定位置開始之指定數目的字元。

參數
startIndex
Int32
要開始刪除字元之以零為起始的位置。

count
Int32
要刪除的字元數。

###    Replace(string,string)

傳回新字串，其中目前字串中指定之 Unicode 字元或 String 的所有項目，全都會被取代成另一個指定的 Unicode 字元或 String。


### Split(Char)
根據指定的分隔字元，將一個字串分割成數個子字串。
回傳由指定的分隔字元分割成的子字串陣列


###    Substring(Int32)
回傳從這個執行個體擷取子字串。 子字串會在指定的字元位置開始並繼續到字串的結尾。


###    ToCharArray()
將這個執行個體中的字元複製到 Char陣列中。


###    ToLower()
傳回此字串轉換為小寫的版本。

###    ToUpper()
傳回此字串轉換為大寫的版本。


###    TrimStart(Char)
回傳移除出現在目前字串開頭的所有指定字元的字串。


###    TrimEnd(Char)
回傳移除出現在目前字串結尾的所有指定字元的字串。


##    Strings 
命名空間:Microsoft.VisualBasic
組件:Microsoft.VisualBasic.dll
Strings 模組包含用來執行字串作業的程序。
此命名空間下的函數與VB6的字串函數相同
多數情況下用String所定義的函數效能比較高

###    Asc(Char)
傳回整數值，以代表某字元的對應ASCII碼。
> [ASCII Code](https://shihyu.github.io/books/apas01.html)

###    AscW(Char)
傳回整數值，以代表某字元的對應unicode碼。
> [unicode](https://shihyu.github.io/books/apas01.html)

###    Chr(Int32)
傳回與指定的ASCII碼關聯的字元。
> [ASCII Code](https://shihyu.github.io/books/apas01.html)

###    ChrW(Int32)
傳回與指定的unicode碼關聯的字元。
> [unicode](https://shihyu.github.io/books/apas01.html)

###    StrReverse(String)
傳回反轉後的字串。

##    Double
命名空間:System
組件:mscorlib.dll

###    PositiveInfinity
表示正無限大。這個欄位為常數。

###    NegativeInfinity
表示負無限大。這個欄位為常數。

##    Math
命名空間:System
組件:mscorlib.dll
繼承 Object

提供三角函數、對數函數和其他一般數學函數的常數和靜態方法。
> [更多資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.math?view=net-7.0)
###    E
代表自然對數底數，由常數 e 指定，這個欄位為常數。
E = 2.7182818284590451

###    PI
代表圓周率，由常數 π 指定，這個欄位為常數。
PI = 3.1415926535897931

###    Abs(num)
傳回num絕對值。
num必須是含正負號的整數或浮點。

###    Sin(Double)
傳回指定角的正弦函數。

###    Asin(Double)
傳回正弦函數 (Sine) 是指定數字的角。

###    Acos(Double)
傳回餘弦函數 (Cosine) 是指定數字的角。

###    Cos(Double)
傳回指定角的餘弦函數。

###    Tan(Double)
傳回指定角的正切函數。

###    Atan(Double)
傳回正切函數 (Tangent) 是指定數字的角。

###    Atan2(Double,Double)
回正切函數是兩個指定數字之商數的角。

###    Ceiling(num)
傳回大於或等於num的最小整數值。
num必須是浮點或Decimal

###    Floor(num)
傳回小於或等於num的最大整數值。
num必須是浮點或Decimal

###    Exp(Double)
傳回具有指定乘冪數的 e。

###    Log(Double, Double)
傳回由第二個引數為底數，第一的引數為真數的對數。

###    Max(A,B)
回傳A,B中較大的那一個

###    Min(A,B)
回傳A,B中較小的那一個

###    Round(num)
最接近 num 的整數。 如果 num 的小數部分正好為兩個整數的中間數 (一個為偶數，另一個為奇數)，則會傳回偶數。 請注意，這個方法會傳回 Double 或 Decimal (視以數而定)，而不是整數類型。
4.4 --> 4
==**4.5 --> 4**==
4.6 --> 5
5.4 --> 5
==**5.5 --> 6**==
5.6 --> 6

###    Sign(num)

傳回整數，表示正負號。

| 回傳值 | 條件  |
|:------:| ----- |
|   -1   | num<0 |
|   0    | num=0 |
|   1    | num>0 |

###    Sqrt(Double)
傳回指定數字的平方根。與(num ^ 0.5)相同

###    Truncate
計算指定的數字的整數部分。

##    Array
命名空間:System
組件:System.Runtime.dll
提供建立、管理、搜尋和排序陣列的方法，可在 Common Language Runtime 時做為所有陣列的基底類別。
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.array?view=net-7.0)
###    Length
取得 Array 所有維度的元素總數。

###    Rank
取得 Array 的陣序 (維度數目)。 例如，一維陣列傳回 1，二維陣列傳回 2，依此類推。

###    Clear(Array)	
清除陣列的內容

###    Clone()	
建立 Array 的淺層複本。

###    Reverse(Array)	
反轉整個一維 Array 中的項目順序。

###    Sort(Array)	
使用指定的 IComparer(T) 泛型介面，排序 Array 中的項目(由小到大)

Sort(array, comparer)

comparer:在比較項目時所使用的 IComparer(T) 泛型介面實作，或 null 使用每個項目的 IComparable(T) 泛型介面實作。
下列為排序的範例
```vb=
Module Module1
    Class cmp
        Implements IComparer(Of String) '用IComparable(T) 泛型介面實作。
        Public Function Compare(x As String, y As String) As Integer Implements IComparer(Of String).Compare 'Array.Sort 預設由小排到大所以我們要自訂比較函數
            Return x.Length - y.Length 'return > 0 ==> x > y ; return = 0 ==> x = y ; return < 0 ==> x < y
        End Function
    End Class
    Sub Main()
        Dim arr() As String = {"1564", "a145456", "A1235245", "14", "000", "0_"}
        Console.WriteLine("{0}預設排序(依 unicode 編碼){0}", vbCrLf)
        Array.Sort(arr) '預設排序 依字碼順序排
        For Each i As String In arr '依序輸出結果
            Console.WriteLine(i)
        Next
        Console.WriteLine("{0}自訂排序(依字串長度){0}", vbCrLf)
        'Array.Sort(arr, New cmp) '自訂排序 依cmp的比較函數實作
        '也可以運用lambda 
    Array.Sort(arr, Function(a , b) a.Length.CompareTo(b.Length))
        For Each i As String In arr '依序輸出結果
            Console.WriteLine(i)
        Next
        While Not Console.KeyAvailable
        End While
    End Sub
End Module
```
![](https://hackmd.io/_uploads/SJaNyGWon.png)

###    BinarySearch(Array, Object) 
使用陣列每個項目和指定物件所實作的 IComparable 介面，在整個**一維已排序的陣列**中搜尋特定的項目。

傳回
Int32
如果找到 value，則為指定的 array 中指定的 value 索引；否則為負數。 如果找不到 value 且 value 小於 array 的一或多個項目，傳回的負數是大於 value 的第一個項目索引的位元補數。 如果找不到 value 且 value 大於 array 的所有項目，**傳回的負數是 (最後一個項目索引加 1) 的位元補數**。 如果以未排序的 array 來呼叫這個方法，傳回值會不正確且可能傳回負數，即使 value 出現在 array 中也一樣。

###    FindIndex(T)(T(), Predicate(T))	
搜尋符合指定之述詞所定義的條件之項目，並傳回整個 Array 內第一次出現之以零為起始的索引。

傳回
Int32
第一次出現符合 Predicate(T) 所定義之條件的項目以零為起始的索引 (如有找到)；否則為 -1。

##    Console
命名空間:System
組件:mscorlib.dll
繼承 Object

表示主控台應用程式 (Console Application) 的標準輸入、輸出和錯誤資料流。 此類別無法獲得繼承。
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.console?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.Console)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)
###    KeyAvailable	
取得值，指出是否可以在輸入資料流中使用按鍵按壓。
實例
```vb=
Sub pause()
    Console.Write("請按任意鍵繼續 . . .")
    While Not Console.KeyAvailable
        System.Threading.Thread.Sleep(100) '避免過度消耗資源
    End While
End Sub
```
==**若用主控台撰寫程式最後一定要加**==

###    Clear()	
清除主控台緩衝區及包含顯示資訊的對應主控台視窗。

###    Read()	
從標準輸入資料流讀取下一個字元。

###    ReadLine()	
從標準輸入資料流讀取下一行字元。

###    Write(Char)	
將指定的字元值寫入標準輸出資料流。

###    WriteLine()	
將目前的行結束字元寫入標準輸出資料流。
這個方法會使用 .NET 的 複合格式化功能 ，將物件的值轉換為其文字表示，並在字串中內嵌該標記法。 產生的字串會寫入至輸出資料流程。

format參數包含零或多個文字，並混合零或多個索引預留位置（稱為格式專案），其對應至這個方法的參數清單中的物件。 格式化進程會以對應物件值的文字表示來取代每一個格式專案。

格式專案的語法是 { 索引[ , 對齊方式] [ : 格式 文字] } ，其指定強制索引、格式化文字的選擇性長度和對齊方式，以及控制對應物件值之格式規範字符的選擇性字串。

.NET 提供廣泛的格式化支援，在下列格式設定主題中有更詳細的說明。

如需數值格式規範的詳細資訊，請參閱 **標準數值格式字串** 和 **自訂數值格式字串**。

如需日期和時間格式規範的詳細資訊，請參閱 **標準日期和時間格式字串** 和 **自訂日期和時間格式字串**。

如需列舉格式規範的詳細資訊，請參閱 **列舉格式字串**。

如需格式化的詳細資訊，請參閱 **格式化類型**。

> [**標準數值格式字串**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/standard-numeric-format-strings)\
> [**自訂數值格式字串**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/custom-numeric-format-strings)\
> [**標準日期和時間格式字串**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/standard-date-and-time-format-strings)\
> [**自訂日期和時間格式字串**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/custom-date-and-time-format-strings)\
> [**列舉格式字串**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/enumeration-format-strings)\
> [**格式化類型**](https://learn.microsoft.com/zh-tw/dotnet/standard/base-types/formatting-types)\
> [Console.WriteLine](https://learn.microsoft.com/zh-tw/dotnet/api/system.console.writeline?view=net-7.0&source=recommendations)
```csharp=
Console.WriteLine("{0, 8 :C}", 2); // $2.00
Console.WriteLine("{0, 8 :C3}", 2); // $2.000
Console.WriteLine("{0 :D3}", 2); // 002
Console.WriteLine("{0 :E}", 2); // 2.000000E+000
Console.WriteLine("{0 :G}", 2); // 2
Console.WriteLine("{0 :N}", 2500000.00); // 2,500,00.00
Console.WriteLine("{0 :x4}", 12); // 000c
Console.WriteLine("{0, 2 :x}", 12); // c
Console.WriteLine("{0 :000.000}", 12.23); // 012.230
Console.WriteLine("{0 :r}", 15.62);// 15.62
Console.WriteLine("{0 :d}", System.DateTime.Now); // 2022-3-17
Console.WriteLine("{0 :D}", System.DateTime.Now); // 2022年3月17日

Console.WriteLine("{0 :t}", System.DateTime.Now); // 11:43
Console.WriteLine("{0 :T}", System.DateTime.Now); // 11:43:34

Console.WriteLine("{0 :f}", System.DateTime.Now); // 2022年3月27日11:43
Console.WriteLine("{0 :F}", System.DateTime.Now); // 2022年3月27日11:43:34

Console.WriteLine("{0 :g}", System.DateTime.Now); // 2022-3-17 11:43
Console.WriteLine("{0 :G}", System.DateTime.Now); // 2022-3-17 11:43:34

Console.WriteLine("{0 :M}", System.DateTime.Now); // 3月17日
Console.WriteLine("{0 :r}", System.DateTime.Now);// Thu, 17 Mar 2022 11:43:34 GMT
Console.WriteLine("{0 :s}", System.DateTime.Now); // 2022-03-17T11:43:34
Console.WriteLine("{0 :u}", System.DateTime.Now); // 2022-03-17 11:43:34Z
Console.WriteLine("{0 :U}", System.DateTime.Now); // 2022年3月17日3:43:34
Console.WriteLine("{0 :Y}", System.DateTime.Now); // 2022年3月

Console.WriteLine("{0 :dd}", System.DateTime.Now); // 27
Console.WriteLine("{0 :ddd}", System.DateTime.Now); // 四
Console.WriteLine("{0 :dddd}", System.DateTime.Now); // 星期四

Console.WriteLine("{0 :f}", System.DateTime.Now); // 2022年3月17日11:46
Console.WriteLine("{0 :ff}", System.DateTime.Now); // 18
Console.WriteLine("{0 :fff}", System.DateTime.Now); // 187
Console.WriteLine("{0 :ffff}", System.DateTime.Now); // 1875
Console.WriteLine("{0 :fffff}", System.DateTime.Now); // 18750

Console.WriteLine("{0 :gg}", System.DateTime.Now); // 公元
Console.WriteLine("{0 :ggg}", System.DateTime.Now); // 公元
Console.WriteLine("{0 :gggg}", System.DateTime.Now); // 公元
Console.WriteLine("{0 :ggggg}", System.DateTime.Now); // 公元
Console.WriteLine("{0 :gggggg}", System.DateTime.Now);// 公元

Console.WriteLine("{0 :hh}", System.DateTime.Now); // 11
Console.WriteLine("{0 :HH}", System.DateTime.Now); // 11

Console.WriteLine("{0 :mm}", System.DateTime.Now); // 50
Console.WriteLine("{0 :MM}", System.DateTime.Now); // 03

Console.WriteLine("{0 :MMM}", System.DateTime.Now); // 三月
Console.WriteLine("{0 :MMMM}", System.DateTime.Now); // 三月

Console.WriteLine("{0 :ss}", System.DateTime.Now); // 43
Console.WriteLine("{0 :tt}", System.DateTime.Now); // 上午

Console.WriteLine("{0 :yy}", System.DateTime.Now); // 12
Console.WriteLine("{0 :yyyy}", System.DateTime.Now); // 2022
Console.WriteLine("{0 :zz}", System.DateTime.Now); // +08
Console.WriteLine("{0 :zzz}", System.DateTime.Now); // +08:00
Console.WriteLine("{0 :hh:mm:ss}", System.DateTime.Now); // 11：43：34
Console.WriteLine("{0 :dd/MM/yyyy}", System.DateTime.Now); // 17-03-2022
```

##    Debug

命名空間:System.Diagnostics
組件:System.Runtime.dll
繼承 Object

提供一組方法和屬性，可協助偵錯程式碼。
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.diagnostics.debug?view=net-7.0)
###    Write()	
將訊息寫入 Listeners 集合中的追蹤接聽項。
(與Console.Write()用法相同)

###    WriteLine()		
將後面接著行結束字元的訊息寫入 Listeners 集合中的追蹤接聽項。
(與Console.Writeln()用法相同)

輸出在這\
![](https://hackmd.io/_uploads/rJqrpB-j2.png)

==用主控台感覺不出來，若是用 windows from 就會知道這個除錯有多好用==

##    Application

==命名空間:System.Windows.Forms==
組件:System.Windows.Forms.dll
繼承 Object

提供 static 方法和屬性以管理應用程式，例如使用方法啟動或停止應用程式、處理 Windows 訊息，以及使用屬性取得有關應用程式的資訊。 此類別無法獲得繼承。
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.windows.forms.application?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.Windows.Forms.Application)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)
###    StartupPath	
取得啟動應用程式的可執行檔路徑，不包括檔名。

###    UserAppDataPath	
取得使用者的應用程式資料路徑。

###    DoEvents()	
處理目前在訊息佇列中的所有 Windows 訊息。

###    Exit()	
通知所有必須結束的訊息幫浦，接著在訊息處理完成之後關閉所有應用程式視窗。

###    ExitThread()	
結束目前執行緒的訊息迴圈，並關閉執行緒上的所有視窗。

###    Restart()	
關閉應用程式並立即啟動新的執行個體。

##    File
定義
命名空間:System.IO
組件:mscorlib.dll
繼承 Object

提供建立、複製、刪除、移動和開啟單一檔案的靜態方法，並協助 FileStream 物件的建立。
(此命名空間下的所有的路徑均要符合 Windows 格式)
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.file?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.IO.File)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)

###    FileAccess 
命名空間:System.IO
組件:mscorlib.dll
定義檔案讀取、寫入或讀取/寫入存取的常數。\
此列舉支援其成員值的位元組合。

| 名稱      | 數值 | 功能                                                              |
| --------- | ---- | ----------------------------------------------------------------- |
| Read      | 1    | 檔案的讀取權限， 資料可以從檔案讀取。 與讀/寫存取的 Write 結合。  |
| Write     | 2    | 寫入檔案的存取權限， 資料可以寫入檔案。 與讀/寫存取的 Read 結合。 |
| ReadWrite | 3    | 讀取和寫入檔案的存取權限， 資料可以寫入檔案和從檔案讀取。         |
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.fileaccess?view=netframework-4.8)
###    FileShare 
命名空間:System.IO
組件:mscorlib.dll
包含常數，用來控制其他 FileStream 物件對於相同檔案可以用的存取方式。

此列舉支援其成員值的位元組合。。


| 名稱        | 數值 | 功能                                                                                                                                                                                                             |
| ----------- |:----:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| None        |  0   | 拒絕共用目前檔案。 任何 (由這個處理序或其他處理序) 開啟檔案的要求將會失敗，直到關閉檔案。                                                                                                                        |
| Read        |  1   | 允許後序開啟檔案進行讀取。 如果未指定這個旗標，任何 (由這個處理序或其他處理序) 開啟檔案進行讀取的要求將會失敗，直到關閉檔案。 然而，即使有指定這個旗標，可能仍然需要其他使用權限，才能存取檔案。                 |
| Write       |  2   | 允許後序開啟檔案進行寫入。 如果未指定這個旗標，任何 (由這個處理序或其他處理序) 開啟檔案進行寫入的要求將會失敗，直到關閉檔案。 然而，即使有指定這個旗標，可能仍然需要其他使用權限，才能存取檔案。                 |
| ReadWrite   |  3   | 允許後序開啟檔案進行讀取或寫入。 如果未指定這個旗標，任何要開啟檔案以進行讀取或寫入的要求 (由這個處理序或其他處理序) 將會失敗，直到關閉檔案。 然而，即使有指定這個旗標，可能仍然需要其他使用權限，才能存取檔案。 |
| Delete      |  4   | 允許後續刪除檔案。                                                                                                                                                                                               |
| Inheritable |  16  | 使檔案控制代碼 (File Handle) 可由子處理序 (Process) 來繼承。 這並非直接由 Win32 來支援。                                                                                                                         |
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.fileshare?view=netframework-4.8)


 ###    FileMode  
命名空間:System.IO
組件:mscorlib.dll
繼承 Object

指定作業系統應該如何開啟檔案。

| 名稱         | 數值 | 功能                                                                                                                                                                                                                                                            |
| ------------ |:----:| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| CreateNew    |  1   | 指定作業系統應該建立新檔案。 這個需要 Write 使用權限。 如果檔案已經存在，則會擲回 IOException 例外狀況。                                                                                                                                                        |
| Create       |  2   | 指定作業系統應該建立新檔案。 若此檔案已經存在，其將會覆寫該檔案。 這個需要 Write 使用權限。 FileMode.Create 等於要求檔案不存在時使用 CreateNew，否則使用 Truncate。 若檔案已經存在但為隱藏檔，則擲回 UnauthorizedAccessException 例外狀況。                     |
| Open         |  3   | 指定作業系統應該開啟現有的檔案。 能否順利開啟檔案，取決於 FileAccess 列舉指定的值。 如果檔案不存在，就會擲回 FileNotFoundException 例外狀況。                                                                                                                   |
| OpenOrCreate |  4   | 指定作業系統，如果檔案存在應該開啟檔案，否則，應該建立新的檔案。 如果檔案是以 FileAccess.Read 開啟，則需要 Read 使用權限。 如果檔案存取方式是 FileAccess.Write，則需要 Write 使用權限。 如果檔案是以 FileAccess.ReadWrite 開啟，則需要 Read 和 Write 使用權限。 |
| Truncate     |  5   | 指定作業系統應該開啟現有的檔案。 檔案一旦開啟，應該截斷檔案使其大小為零個位元組。 這個需要 Write 使用權限。 嘗試讀取以 FileMode.Truncate 開啟的檔案會導致 ArgumentException 例外狀況。                                                                          |
| Append       |  6   | 在檔案存在時開啟它並搜尋至檔案末端，或建立新檔案。 這個需要 Append 使用權限。 FileMode.Append 只能與 FileAccess.Write 一起使用。 嘗試搜尋到檔案結尾前的位置會擲回 IOException 例外狀況，而且任何讀取嘗試都會失敗並擲回 NotSupportedException 例外狀況。         |
> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.filemode?view=netframework-4.8)

###    ReadAllBytes(String)	
開啟二進位檔案，將檔案內容讀入位元組陣列，然後關閉檔案。
回傳Boolen()

###    ReadAllText(String, Encoding)	
開啟檔案，利用指定的編碼方式讀取檔案中的所有文字，然後關閉該檔案
```vb=
File.ReadAllText("檔案路徑", System.Text.Encoding.ASCII)
File.ReadAllText("檔案路徑", System.Text.Encoding.BigEndianUnicode)
File.ReadAllText("檔案路徑", System.Text.Encoding.Default)
File.ReadAllText("檔案路徑", System.Text.Encoding.Unicode)
File.ReadAllText("檔案路徑", System.Text.Encoding.UTF7)
File.ReadAllText("檔案路徑", System.Text.Encoding.UTF8)
File.ReadAllText("檔案路徑", System.Text.Encoding.UTF32)
File.ReadAllText("檔案路徑", System.Text.Encoding.GetEncoding(950)) '傳回指定字碼頁的編碼方式。 Big5 950
```

###    WriteAllBytes(String, Byte[])	
建立新檔案，將指定的位元組陣列寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。

###    WriteAllText(String, String, Encoding)	
建立新檔案，使用指定的編碼方式將指定的字串寫入檔案，然後關閉檔案。 如果檔案已經存在，則會覆寫該檔案。
Encoding 定義在命名空間 System.Text.Encoding 編碼用法與File.ReadAllText相同

#    檔案讀寫
##    StreamReader 
命名空間:System.IO
組件:mscorlib.dll
繼承 Object

實作以特定的編碼方式自位元組資料流讀取字元的 TextReader。

> [相關資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.streamreader?view=net-7.0)

###    初始化
```vb=
Dim inp As IO.StreamReader = New IO.StreamReader("檔案路徑")
```
###    CurrentEncoding	
取得目前 StreamReader 物件使用的目前字元編碼。

###    EndOfStream	
取得表示現行資料流位置是否在資料流結尾的值。

###    Close()	
關閉 StreamReader 物件和基礎資料流，並釋放任何與讀取器相關聯的系統資源。

###    Dispose()	
釋放由 TextReader 物件使用的所有資源。
(繼承來源 TextReader)

###    Peek()	
傳回下一個可供使用的字元，但不使用它。

###    Read()	
自輸入資料流讀取下一個字元，並將字元位置前移一個字元。
(與 Console.Read() 用法相同)

###    ReadLine()	
自目前資料流讀取一行字元，並將資料以字串傳回。
(與 Console.ReadLine() 用法相同)

###    ReadToEnd()	
讀取從目前位置到資料流末端的所有字元。

##    StreamWriter

命名空間:System.IO
組件:mscorlib.dll
繼承 Object

實作以特定的編碼方式將字元寫入位元組資料流的 TextWriter。

> [相關資料](https://learn.microsoft.com/zh-tw/dotnet/api/system.io.StreamWriter?view=net-7.0)
###    初始化
```vb=
Dim out As IO.StreamWriter = New IO.StreamWriter("檔案路徑")
```

###    Encoding	
取得寫入輸出的 Encoding。

###    NewLine	
取得或設定目前 TextWriter 所使用的行結束字元字串。
(繼承來源 TextWriter)

###    Close()	
關閉目前的 StreamWriter 物件和基礎資料流。

###    Dispose()	
釋放由 TextWriter 物件使用的所有資源。
(繼承來源 TextWriter)

###    Flush()	
清除目前寫入器 (Writer) 的所有緩衝區，並且造成所有緩衝資料都寫入基礎資料流。

###    Write()	
將文字表示寫入文字資料流。
(繼承來源 TextWriter)
(與 Console.Write 用法相同)

###    WriteLine()	
將行結束字元寫入文字資料流。
(繼承來源 TextWriter)
(與 Console.WriteLine 用法相同)

#    亂數

##    Random 
命名空間:System
組件:mscorlib.dll
繼承 Object

表示虛擬亂數產生器，此演算法可產生符合特定隨機統計需求的數字序列。

> [相關資料](https://learn.microsoft.com/zh-tw/dotnet/api/microsoft.visualbasic.vbmath.rnd?view=net-7.0)

###    初始化
```vb=
Dim rand As New Random()
```

###    Next()	
傳回非負值的隨機整數。

###    Next(Int32)	
傳回小於指定之最大值的非負值隨機整數。

###    Next(Int32, Int32)	
傳回指定範圍內的隨機整數。

###    NextBytes(Byte[])	
以亂數填入指定位元組陣列的元素。

###    NextDouble()	
傳回大於或等於 0.0，且小於 1.0 的隨機浮點數。

###    Sample()	
傳回 0.0 和 1.0 之間的隨機浮點數。

#    容器
定義在 System.Collections.Generic 命名空間，包含定義泛型集合的介面和類別，其允許使用者建立強型別集合，這些集合提供比起非泛型強型別集合更佳的型別安全和效能。

==**熟悉容器的使用方法可以大幅增加程式效能與撰寫速度**==

[相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic?view=netframework-4.8.1)

## List(of T)
命名空間:System.Collections.Generic
組件:mscorlib.dll
繼承 Object

表示可以依照索引存取的強類型物件清單。 提供搜尋、排序和管理清單的方法

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.list-1?view=netframework-4.7.2)

### 初始化
```vb=
'任意型態均可
Dim list As List(Of (資料型態)) = New List(Of (資料型態))
```

###    Count	
取得 List(of T) 中所包含的項目數。

###    Item(Int32)
在指定的索引位置上取得或設定項目。
與 變數名稱(索引值 相同)。

###    Add(T)	
將物件加入至 List(of T) 的末端。

###    Remove(T)	
從 List(of T) 移除特定物件之第一個符合的元素。

###    Clear()	
移除 List(of T) 中的所有項目。

###    BinarySearch(T)	
使用預設的比較子並傳回項目以零為起始的索引，來搜尋項目之整個排序的 List(of T)。


###    IndexOf(T)	
搜尋指定的物件，並傳回整個 List(of T) 中第一個出現之以零為起始的索引。

###    Insert(Int32, T)	
將項目插入至 List(of T) 中指定的索引位置。

###    Reverse()	
反轉整個 List(of T) 中項目的順序。

###    ToArray()	
將 List(of T) 的項目複製到新的陣列。

###    Sort()	
使用預設的比較子來排序在整個 List(of T) 中的項目。

Sort(Comparison(Of T))	
使用指定的 Comparison(Of T) 來排序在整個 List(Of T) 中的項目。
與A
```vb=
Module Module1
    Class cmp
        Implements IComparer(Of String) '用IComparable(Of T) 泛型介面實作。
        Public Function Compare(x As String, y As String) As Integer Implements IComparer(Of String).Compare '自訂比較函數
            Return x.Length - y.Length 'return > 0 ==> x > y ; return =0 ==> x = y ; return < 0 ==> x < y
        End Function
    End Class
    Sub printlist(Of T)(ByVal mylist As List(Of T), Optional str_ As String = "") '輸出list所有元素
        Console.Write(str_)
        For Each i As Object In mylist
            Console.WriteLine(i)
        Next
    End Sub
    Sub pause()
        Console.Write("請按任意鍵繼續 . . .")
        While Not Console.KeyAvailable
        End While
    End Sub
    Sub Main()
        Dim mylist As List(Of String) = New List(Of String) From {"123", "---", "1,", "dfwerfgerf", "12312"} '初始化
        printlist(mylist, "排序前:" + vbCrLf)
        'mylist.Sort(New cmp) '依自訂排序方式排序
        mylist.Sort(Function(a, b) a.Length.CompareTo(b.Length)) '運用lambda
        '輸出結果
        printlist(mylist, "排序後:" + vbCrLf)
        pause()
    End Sub

End Module
```
範例輸出\
![](https://hackmd.io/_uploads/rkmDdEIi2.png)

自訂結構或物件排序
可以用與上面相同的方式將自訂的結構或物件做排序或是將判斷方法寫進結構或物件當中如下範例
```vb=
Module Module1
    Class msclass
        Implements IComparable(Of msclass) '用IComparable(Of T) 泛型介面實作。
        Dim name As String
        Dim no As Integer
        Sub New() '建構式
            name = ""
            no = -1
        End Sub
        Sub New(name_ As String, no_ As Integer) '建構式(方便實作)
            name = name_
            no = no_
        End Sub
        Public Overrides Function ToString() As String '覆寫 Object.ToString 方法
            Return no.ToString() + vbTab + name
        End Function
        Public Function CompareTo(other As msclass) As Integer Implements IComparable(Of msclass).CompareTo '自訂比較函數
            Return no - other.no 'return > 0 ==> x > y ; return =0 ==> x = y ; return < 0 ==> x < y
        End Function
    End Class
    Sub printlist(Of T)(ByVal list As List(Of T), Optional str_ As String = "") '輸出list所有元素
        Console.Write(str_)
        For Each i As Object In list
            Console.WriteLine(i) 'Console.WriteLine 會用Object.ToString 方法將引數轉為 String 若是用自訂結構(物件)需要覆寫 Object.ToString 方法
        Next
    End Sub
    Sub Main()
        Dim list As List(Of msclass) = New List(Of msclass) From {New msclass("222", 2), New msclass("123", 0), New msclass("4521", 4), New msclass("2145", 9)} '初始化
        printlist(list, "排序前:" + vbCrLf)
        list.Sort() '依自訂排序方式排序
        printlist(list, "排序後:" + vbCrLf)
        pause()
        list(0).ToString()
    End Sub
    Sub pause()
        Console.Write("請按任意鍵繼續 . . .")
        While Not Console.KeyAvailable
        End While
    End Sub
End Module
```
範例輸出\
![](https://hackmd.io/_uploads/H1ZOBSIjh.png)

##    LinkedList(Of T)

命名空間:System.Collections.Generic
組件:System.dll
繼承Object

代表雙向連結串列。

**插入與移除效率極高，尋找元素效率極低。除非有必要不然比賽建議以List取代**

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.linkedlist-1?view=netframework-4.7.2)

###    初始化

```vb=
Dim list As LinkedList(Of (資料型態)) = New LinkedList(Of (資料型態))
```

###    Count	
取得在 LinkedList(Of T) 中實際包含的節點數。

###    First	
取得 LinkedList(Of T) 的第一個節點。

###    Last	
取得 LinkedList(Of T) 的最後一個節點。
###    AddAfter(LinkedListNode(Of T), LinkedListNode(Of T))	
在 LinkedList(Of T) 中指定的現有節點後加入指定的新節點。

###    AddAfter(LinkedListNode(Of T), T)	
在 LinkedList(Of T) 中指定的現有節點後加入包含指定值的新節點。

###    AddBefore(LinkedListNode(Of T), LinkedListNode(Of T))	
在 LinkedList(Of T) 中指定的現有節點前加入指定的新節點。

###    AddBefore(LinkedListNode(Of T), T)	
在 LinkedList(Of T) 中指定的現有節點前加入包含指定值的新節點。

###    AddFirst(LinkedListNode(Of T))	
在 LinkedList(Of T) 的開頭加入指定的新節點。

###    AddFirst(T)	
在 LinkedList(Of T) 的開頭加入包含指定值的新節點。

###    AddLast(LinkedListNode(Of T))	
在 LinkedList(Of T) 的結尾加入指定的新節點。

###    AddLast(T)	
在 LinkedList(Of T) 的結尾加入包含指定值的新節點。

###    Clear()	
從 LinkedList(Of T) 移除所有節點。

###    Contains(T)	
判斷值是否在 LinkedList(Of T) 中。

###    Find(T)	
尋找包含指定值的第一個節點。

###    Remove(LinkedListNode(Of T))	
從 LinkedList(Of T) 移除指定的節點。

###    Remove(T)	
從 LinkedList(Of T)中移除第一次出現的指定值。

###    RemoveFirst()	
移除 LinkedList(Of T) 開頭的節點。

###    RemoveLast()	
移除 LinkedList(Of T) 結尾的節點。

##    Queue(Of T)

命名空間:System.Collections.Generic
組件:System.dll
繼承Object

表示相同特定類型之執行個體的各種大小的先進先出 (FIFO) 集合。

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.queue-1?view=netframework-4.7.2)

###    初始化
```vb=
Dim queue As Queue(Of (資料型態)) = New Queue(Of (資料型態))
```

###    Count	
取得 Queue(Of T) 中所包含的項目數。

###    Clear()	
從 Queue(Of T) 移除所有物件。

###    Contains(T)	
判斷某項目是否在 Queue(Of T) 中。

###    Enqueue(T)	
將物件加入至 Queue(Of T) 的末端。

###    Dequeue()	
移除並傳回在 Queue(Of T) 開頭的物件。

###    Peek()	
傳回 Queue(Of T) 開頭的物件而不移除它。

##    Stack(Of T)

命名空間:System.Collections.Generic
組件:System.dll
繼承Object

表示相同特定類型之執行個體的各種大小後進先出 (LIFO) 集合。

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.stack-1?view=net-7.0)

###    初始化
```vb=
Dim stack As Stack(Of (資料型態)) = New Stack(Of (資料型態))
```

###    Count	
取得 Stack(Of T) 中所包含的項目數。

###    Clear()	
從 Stack(Of T) 移除所有物件。

###    Contains(T)	
判斷某項目是否在 Stack(Of T) 中。

###    Peek()	
傳回 Stack(Of T) 頂端的物件而不需移除它。

###    Pop()	
移除並傳回在 Stack(Of T) 頂端的物件。

###    Push(T)	
將物件插入 Stack(Of T) 的頂端。

##    HashSet(Of T)

命名空間:System.Collections.Generic
組件:System.Core.dll
繼承Object

類別 HashSet(Of T) 提供高效能集合作業。 集合是一個集合，其中包含沒有重複的專案，而且其元素沒有特定順序。

**判斷任何物件或數值是否重複都能運用雜湊表快速解決**

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.hashset-1?view=net-7.0)

###    初始化

```vb=
Dim msset As HashSet(Of (資料型態)) = New HashSet(Of (資料型態))
```

###    Count	
取得集合中包含的項目數。

###    Add(T)	
將指定的項目加入至集合。

###    Clear()	
將所有項目從 HashSet(Of T) 物件中移除。

###    Contains(T)	
判斷 HashSet(Of T) 物件是否包含指定的項目。

###    Remove(T)	
將指定的項目從 HashSet(Of T) 物件中移除。

##    Dictionary(Of TKey,TValue)

命名空間:System.Collections.Generic
組件:mscorlib.dll
繼承Object

類型參數
TKey
字典中的索引鍵類型。

TValue
字典中的值類型。

用法給定TKey 回傳TValue
實作為雜湊表，使用索引鍵擷取值非常快速，接近 O(1)。

> [相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.collections.generic.dictionary-2?view=net-7.0)

###    初始化

```vb=
Dim map As Dictionary(Of (資料型態0), (資料型態1)) = New Dictionary(Of (資料型態0), (資料型態1))
```

###    Count	
取得 Dictionary(Of TKey,TValue) 中所包含的索引鍵/值組數目。

###    Item(TKey)
取得或設定與指定之索引鍵相關聯的值。

###    Keys	
取得集合，包含 Dictionary(Of TKey,TValue) 中的索引鍵。

###    Values	
取得集合，包含 Dictionary(Of TKey,TValue) 中的值。

###    Add(TKey, TValue)	
將指定的索引鍵和值加入字典。

###    Clear()	
從 Dictionary(Of TKey,TValue) 移除所有索引鍵和值。

###    ContainsKey(TKey)	
判斷 Dictionary(Of TKey,TValue) 是否包含特定索引鍵。

###    ContainsValue(TValue)	
判斷 Dictionary(Of TKey,TValue) 是否包含特定值。

###    Remove(TKey)	
將具有指定索引鍵的值從 Dictionary(Of TKey,TValue) 中移除。

###    TryGetValue(TKey, TValue)	
取得與指定索引鍵關聯的值。
與Item(TKey)相同

範例
```vb=
Module Module1
    Sub printarr(Of T)(ParamArray ByVal obj() As Object) '輸出陣列所有元素
        For Each i As Object In obj
            Console.Write(i & " ") 'Console.WriteLine 會用Object.ToString 方法將引數轉為 String 若是用自訂結構(物件)需要覆寫 Object.ToString 方法
        Next
        Console.WriteLine()
    End Sub
    Sub Main()
        Dim map As Dictionary(Of String, Integer) = New Dictionary(Of String, Integer)
        map.Add("陳大量", 0) '加入map
        map("張曉縣") = 2 '同上
        map("張曉縣") = 1 '重複會修改 Value值(Key值不能重複)
        map("陳水後") = -2
        If map.ContainsKey("陳大量") Then
            Console.WriteLine("yes")
        End If
        Console.WriteLine("Count = {0},Item(TKey) {1}", map.Count, map("張曉縣"))
        map.Remove("陳水後") '移除
        printarr(Of String)(map.Keys.ToArray)
        pause()
    End Sub
    Sub pause()
        Console.Write("請按任意鍵繼續 . . .")
        While Not Console.KeyAvailable
        End While
    End Sub
End Module
```
範例輸出\
![](https://hackmd.io/_uploads/SkwA6B8oh.png)

#    圖片控制繪圖

##    Bitmap

命名空間:System.Drawing
組件:System.Drawing.dll
繼承 Object

封裝 GDI+ 點陣圖，這個點陣圖是由圖形影像的像素資料及其屬性所組成。 Bitmap 是用來處理像素資料所定義影像的物件。

>[相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.drawing.bitmap?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.Drawing.Bitmap)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)

###    初始化

~~~vb=
Dim bitmap1 As Bitmap = New Bitmap(PictureBox1.Image)'從指定的現有影像初始化 Bitmap 類別的新執行個體。
Dim bitmap2 As Bitmap = New Bitmap(PictureBox1.Width, PictureBox1.Height)'使用指定的大小，初始化 Bitmap 類別的新執行個體。
~~~

###    Flags	
取得這個 Image 之像素資料的屬性旗標。
(繼承來源 Image)

###    Palette	
取得或設定用於這個 Image 的調色盤。
(繼承來源 Image)

###    PixelFormat	
取得這個 Image 的像素格式。
(繼承來源 Image)

###    PropertyIdList	
取得儲存在這個 Image 中的屬性項目 ID。
(繼承來源 Image)

###    PropertyItems	
取得儲存在這個 Image 中的所有屬性項目 (中繼資料的各個項目)。
(繼承來源 Image)

###    RawFormat	
取得這個 Image 的檔案格式。
(繼承來源 Image)

###    Size	
取得影像的寬度和高度，單位為像素。
(繼承來源 Image)

###    Tag	
取得或設定物件，該物件提供影像的其他相關資料。
(繼承來源 Image)

###    Height	
取得這個 Image 的高度 (單位為像素)。
(繼承來源 Image)

###    Width	
取得這個 Image 的寬度 (單位為像素)。
(繼承來源 Image)

###    PhysicalDimension	
取得這個影像的寬度和高度。
(繼承來源 Image)

###    VerticalResolution	
取得這個 Image 的垂直解析度 (單位為每英吋的像素)。
(繼承來源 Image)

###    HorizontalResolution	
取得這個 Image 的水平解析度 (單位為每英吋的像素)。
(繼承來源 Image)

###    Clone()	
建立這個 Image 的完全相同複本。
(繼承來源 Image)

###    Dispose()	
釋放這個 Image 所使用的所有資源。
(繼承來源 Image)

###    GetPixel(Int32, Int32)	
取得這個 Bitmap 中指定像素的色彩。

###    SetPixel(Int32, Int32, Color)	
設定此 Bitmap 中指定之像素的色彩。

###    GetThumbnailImage(Int32, Int32, Image.GetThumbnailImageAbort, IntPtr)
傳回這個 Image 的縮圖。
(繼承來源 Image)

範例
~~~vb=
Private Sub Button2_Click() Handles Button2.Click
    Dim bitmap1 As Bitmap = New Bitmap(PictureBox1.Image)
    PictureBox2.Image = bitmap1.GetThumbnailImage(bitmap1.Width / 2, bitmap1.Height / 2, Function() False, IntPtr.Zero)
    '前兩個引數決定寬跟高，後兩的引數不要動。
End Sub
~~~
範例輸出\
![](https://hackmd.io/_uploads/SkzupOUi2.png)
> **註1:** Function() False 為 Lambda 是沒有名稱的函式或副程式，可在委派有效的地方使用。 Lambda 運算式可以是函式或副程式，而且可以是單行或多行。 您可以將值從目前範圍傳遞至 Lambda 運算式。\
**註2:** 第四個引數必須是 IntPtr.Zero

>[關於Lambad](https://learn.microsoft.com/zh-tw/dotnet/visual-basic/programming-guide/language-features/procedures/lambda-expressions)

###    MakeTransparent()	
可讓這個 Bitmap的預設透明色彩為透明。

###    RotateFlip(RotateFlipType)	
旋轉、翻轉或者同時旋轉和翻轉 Image。
(繼承來源 Image)
利用RotateFlipType 列舉所定義的方式旋轉
####    RotateFlipType 列舉
命名空間:System.Drawing
組件:System.Drawing.dll
繼承 Object

指定影像的旋轉量以及用來翻轉影像的座標軸。


| 名稱               | 數值 | 功能                                            |
| ------------------ | ---- |:----------------------------------------------- |
| RotateNoneFlipNone | 0    | 指定不順時針旋轉也不翻轉。                      |
| Rotate180FlipXY    | 0    | 指定 180 度順時針旋轉，後面接續水平和垂直翻轉。 |
| Rotate90FlipNone   | 1    | 指定不翻轉的 90 度順時針旋轉。                  |
| Rotate270FlipXY    | 1    | 指定 270 度順時針旋轉，後面接續水平和垂直翻轉。 |
| Rotate180FlipNone  | 2    | 指定不翻轉的 180 度順時針旋轉。                 |
| RotateNoneFlipXY   | 2    | 指定不順時針旋轉，後面接續水平和垂直翻轉。      |
| Rotate90FlipXY     | 3    | 指定 90 度順時針旋轉，後面接續水平和垂直翻轉。  |
| Rotate270FlipNone  | 3    | 指定不翻轉的 270 度順時針旋轉。                 |
| Rotate180FlipY     | 4    | 指定 180 度順時針旋轉，後面接續垂直翻轉。       |
| RotateNoneFlipX    | 4    | 指定不順時針旋轉，後面接續水平翻轉。            |
| Rotate90FlipX      | 5    | 指定 90 度順時針旋轉，後面接續水平翻轉。        |
| Rotate270FlipY     | 5    | 指定 270 度順時針旋轉，後面接續垂直翻轉。       |
| Rotate180FlipX     | 6    | 指定 180 度順時針旋轉，後面接續水平翻轉。       |
| RotateNoneFlipY    | 6    | 指定不順時針旋轉，後面接續垂直翻轉。            |
| Rotate90FlipY      | 7    | 指定 90 度順時針旋轉，後面接續垂直翻轉。        |
| Rotate270FlipX     | 7    | 指定 270 度順時針旋轉，後面接續水平翻轉。       |

>[相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.drawing.rotatefliptype?view=windowsdesktop-7.0)

###    Save(String)	
儲存這個 Image 至指定的檔案或資料流。
(繼承來源 Image)

##    Graphics

命名空間:System.Drawing
組件:System.Drawing.dll
繼承 Object

封裝 GDI+ 繪圖介面。 此類別無法獲得繼承。
>[相關資訊](https://learn.microsoft.com/zh-tw/dotnet/api/system.drawing.graphics?view=netframework-4.8&f1url=%3FappId%3DDev16IDEF1%26l%3DZH-TW%26k%3Dk(System.Drawing.Graphics)%3Bk(TargetFrameworkMoniker-.NETFramework%2CVersion%253Dv4.8)%3Bk(DevLang-VB)%26rd%3Dtrue)
###    FromImage(Image)	
從指定的 Graphics 建立新 Image。

###    Clear(Color)	
清除整個繪圖介面，並使用指定的背景色彩填滿它。

###    Dispose()	
釋放這個 Graphics 所使用的所有資源。

###    DrawArc(Pen, Int32, Int32, Int32, Int32, Int32, Int32)
繪製弧形，表示由一對座標、寬度和高度所指定的橢圓形的一部分。

參數
1. 決定弧形的色彩、寬度和樣式。
2. 矩形左上角的 X 座標，這個矩形定義橢圓形。
3. 矩形左上角的 Y 座標，這個矩形定義橢圓形。
4. 定義橢圓形的矩形的寬度。
5. 定義橢圓形的矩形的高度。
6. 以度為單位，依順時針方向測量之從 X 軸到弧形開始點的角度。
7. 以度為單位，依順時針方向測量之從 startAngle 參數到弧形結束點的角度。

###    DrawEllipse(Pen, Int32, Int32, Int32, Int32)	
繪製由矩形左上角、高度和寬度的座標指定之週框所定義的橢圓形。

參數
1. 決定橢圓形的色彩、寬度和樣式。
2. 週框左上角的 X 軸座標，這個週框定義橢圓形
3. 週框左上角的 Y 軸座標，這個週框定義橢圓形。
4. 週框的寬度，這個週框定義橢圓形。
5. 週框的高度，這個週框定義橢圓形。

###    DrawEllipse(Pen, Rectangle)	
繪製由界限 Rectangle 結構指定的橢圓形。
Rectangle 儲存四個為一組的整數，代表矩形的位置和大小

###    DrawImage(Image, Int32, Int32)	
使用原始的實體大小將指定的影像繪製於座標對所指定的位置。

###    DrawLine(Pen, Int32, Int32, Int32, Int32)	
繪製連接由座標對所指定的兩個點之直線。


參數
1. 決定線段的色彩、寬度和樣式。
2. 第一點的 X 座標。 ==必須是單精確浮點數(Single)或整數==
3. 第一點的 Y 座標。 ==必須是單精確浮點數(Single)或整數==
4. 第二點的 X 座標。 ==必須是單精確浮點數(Single)或整數==
5. 第二點的 Y 座標。 ==必須是單精確浮點數(Single)或整數==

###    DrawLines(Pen, Point())	
繪製連接 Point 結構陣列的一系列直線線段。

###    DrawPolygon(Pen, Point())	
繪製由 Point 結構陣列定義的多邊形。

###    DrawRectangle(Pen, Int32, Int32, Int32, Int32)	
繪製由座標對、寬度和高度所指定的矩形。

參數
1. 決定矩形的色彩、寬度和樣式。
2. 要繪製之矩形左上角的 X 座標。
3. 要繪製之矩形左上角的 Y 座標。
4. 要繪製的矩形的寬度。
5. 要繪製的矩形的高度。

###    DrawRectangle(Pen, Rectangle)	
繪製由 Rectangle 結構指定的矩形。

###    DrawRectangles(Pen, Rectangle[])	
繪製由 Rectangle 結構所指定的一系列矩形。

###    DrawString(String, Font, Brush, Single, Single)
使用指定的 Brush 和 Font 物件，將指定的文字字串繪製於指定的位置。
Font 定義文字的特定格式，包括字體、大小和樣式屬性 (Attribute)。 此類別無法獲得繼承。
Brush 定義用於填滿圖形形狀內部的物件，例如矩形、橢圓形、派形、多邊形和路徑。
範例
~~~vb=
Private Sub Button2_Click(sender As Object, e As EventArgs) Handles Button2.Click
    Dim img As Bitmap = New Bitmap(PictureBox1.Width, PictureBox1.Height)
    Dim g As Graphics = Graphics.FromImage(img)
    g.DrawString("Hello World", New Font("新細明體", 24, FontStyle.Bold), Brushes.Black, 100, 100)
    PictureBox1.Image = img
End Sub
~~~
範例輸出\
![](https://hackmd.io/_uploads/r1T4qY8o3.png)

###    FillEllipse(Brush, Int32, Int32, Int32, Int32)	
填滿由座標對、寬度和高度指定的周框所定義的橢圓形內部。

參數
1. Brush，決定填滿的特性。
2. 週框左上角的 X 軸座標，這個週框定義橢圓形。
3. 週框左上角的 Y 軸座標，這個週框定義橢圓形。
4. 週框的寬度，這個週框定義橢圓形。
5. 週框的高度，這個週框定義橢圓形。

###    FillPolygon(Brush, Point[])	
填滿由 Point 結構指定的點陣列所定義的多邊形內部。

###    FillRectangle(Brush, Int32, Int32, Int32, Int32)	
填滿由座標對、寬度和高度指定的矩形內部。

參數
1. Brush，決定填滿的特性。
2. 要填滿之矩形左上角的 X 座標。
3. 要填滿之矩形左上角的 Y 座標。
4. 要填滿的矩形的寬度。
5. 要填滿的矩形的高度。

###    RotateTransform(Single)	
將指定的旋轉套用至這個 Graphics 的變換矩陣。
參數
1. 旋轉的角度，以度為單位。


#    演算法

##    找質數(質數篩法)

質數的定義是 只有1與該數本身兩個正因數的數

最簡單的方式就是把所有比他小的整數都試一次若沒有能整除他的數那這個數就是質數。
這個方法寫起來很快，但如果需要重複查詢或是要找很大的質數就會需要做很多次的運算。導致程式效能低下。
如果要提升程式的執行效能我們能換一個方式實作。
質數的因數只有1跟自己，換句話說大於2的偶數絕對不是質數，因為大於2的偶數都有2這個因數，而且質數的倍數都不是質數。我們就能運用這個想法來實作。

1. 先設定大小等同於要找的質數範圍相同的布林陣列(false 代表質數 true 代表非質數)
2. 去除小於2的非質數
3. 去除2的倍數
4. 從3開始每次加2碰到的false必是質數 並打這個數的倍數去除
5. 做完後陣列中的false都是質數

~~~vb=
Private Sub Find_prime(ByRef prime() As Boolean)  '找這個範圍內的質數
    Array.Clear(prime, 0, prime.Length) '將陣列中的元數設為false
    prime(0) = True '0與1不是質數
    prime(1) = True
    For i As Int32 = 4 To prime.Length - 1 Step 2 '2的倍數不是質數
        prime(i) = True
    Next
    For i As Int32 = 3 To prime.Length - 1 Step 2 '只找奇數
        If Not prime(i) Then
            For j As Int32 = 3 To prime.Length - 1 Step 2 '去除質數的倍數
                If j * i > prime.Length Then Exit For
                prime(j * i) = True
            Next
        End If
    Next
End Sub
~~~

範例輸出\
![](https://hackmd.io/_uploads/ryZDDtDin.png)



##    大數運算
利用直式算法的想法
~~~vb=
Private Function Cmp(a As String, b As String) As Int16 '比較
    If a = b Then '等於
        Return 0
    ElseIf (a.Length = b.Length AndAlso a > b) OrElse a.Length > b.Length Then '大於
        Return 1
    Else
        Return -1 '小於
    End If
End Function
Private Function Big_Add(a As Char(), b As Char()) As String '正整數加法
    Dim arr As New List(Of Int16) '計算用
    Dim ret As String = "" '儲存回傳值
    Dim carry As Int16 = 0 '進位
    Array.Reverse(a) '陣列反轉
    Array.Reverse(b)
    For i As Int32 = 1 To Math.Max(a.Length, b.Length)
        arr.Add(0)
    Next
    For i As Int32 = 0 To a.Length - 1 '計算
        arr(i) += Asc(a(i)) - &H30
    Next
    For i As Int32 = 0 To b.Length - 1
        arr(i) += Asc(b(i)) - &H30
    Next
    For i As Int32 = 0 To arr.Count - 1 '進位
        arr(i) += carry
        carry = arr(i) \ 10
        arr(i) = arr(i) Mod 10
    Next
    If carry > 0 Then arr.Add(carry)
    For Each i As Int32 In arr '轉為字串
        ret = i & ret
    Next
    Return ret
End Function

Private Function Big_Sub(a As Char(), b As Char()) As String '正整數減法
    Dim arr As New List(Of Int32) '計算用
    Dim ret As String = "" '回傳值
    Dim carry As Int32 = 0 '借位
    Dim nenegative_flag = False '負值旗標
    If Cmp(a, b) = -1 Then '若a < b ==> (a - b) = -(b - a)
        Dim bufer() As Char = a.Clone '交換
        a = b.Clone
        b = bufer
        nenegative_flag = True '舉起負值旗標
    ElseIf Cmp(a, b) = 0 Then '若兩數相等答案為0
        Return "0"
    End If
    Array.Reverse(a) '反轉陣列
    Array.Reverse(b)
    For i As Int32 = 1 To Math.Max(a.Length, b.Length) '兩正整數相減不會比原本長
        arr.Add(0)
    Next
    For i As Int32 = 0 To b.Length - 1
        arr(i) -= (Asc(b(i)) - &H30)
    Next
    For i As Int32 = 0 To a.Length - 1
        arr(i) += (Asc(a(i)) - &H30 - carry)
        If arr(i) < 0 Then '借位
            arr(i) += 10
            carry = 1
        Else
            carry = 0
        End If
    Next
    For Each i As Int32 In arr '轉為字串
        ret = i & ret
    Next
    ret = ret.TrimStart("0"c) '去除前方多餘的0
    If nenegative_flag Then ret = "-"c + ret '負值旗標是否舉起
    Return ret
End Function

Private Function Big_Mul(a As Char(), b As Char()) As String '正整數乘法
    Dim arr As New List(Of Int32) '計算用
    Dim ret As String = "" '回傳值
    Dim carry As Int32 = 0 '進位
    If Cmp(a, "0"c) = 0 OrElse Cmp(b, "0"c) = 0 Then
        Return "0"
    End If
    Array.Reverse(a) '反轉陣列
    Array.Reverse(b)
    For i As Int32 = 1 To a.Length + b.Length '兩數相乘的長度不會超過兩數相加
        arr.Add(0)
    Next
    For i As Int32 = 0 To a.Length - 1
        For j As Int32 = 0 To b.Length - 1
            arr(i + j) += (Asc(a(i)) - &H30) * (Asc(b(j)) - &H30) '直式乘法
        Next
    Next
    For i As Int32 = 0 To arr.Count - 1 '進位
        arr(i) += carry
        carry = arr(i) \ 10
        arr(i) = arr(i) Mod 10
    Next
    For Each i As Int32 In arr '轉為字串
        ret = i & ret
    Next
    ret = ret.TrimStart("0"c) '去除前方多餘的0
    Return ret
End Function

Private Function Big_Div(a As String, b As String) As String '正整數除法
    Dim sum As Int32 = 0 '紀錄省略的0
    Dim ret As String = "" '回傳值
    Dim num As String = "" '餘數
    If Cmp(a, b) = 0 Then 'a = b
        Return "1 餘 0"
    ElseIf Cmp(a, b) = -1 Then 'a < b
        Return "0 餘 " + a
    End If
    While a.Last = "0"c AndAlso b.Last = "0"c '省略兩數最後的0
        a = a.Substring(0, a.Length - 1)
        b = b.Substring(0, b.Length - 1)
        sum += 1
    End While
    While a.Length > 0  ' 直式除法
        While Cmp(b, num) = 1 AndAlso a.Length > 0
            num += a.First
            a = a.Substring(1)
        End While
        For i As Int16 = 9 To 1 Step -1
            If Cmp(Big_Mul(b, i.ToString), num) <> 1 Then '(b * i) <= num
                ret += i.ToString
                num = Big_Sub(num, Big_Mul(b, i.ToString))
                num = num.TrimStart("0"c)
                Exit For
            End If
        Next
    End While
    For i As Int32 = 1 To sum '把省略的0放回去
        num += "0"c
    Next
    num = num.TrimStart("0"c) '去除前方的0
    If num = vbNullString Then num = "0"
    Return ret.TrimStart("0"c) + " 餘 " + num
End Function

Private Function Big_Divide(a As String, b As String) As String '整除
    a = Big_Div(a, b)
    Return a.Substring(0, a.IndexOf(" "c))
End Function

Private Function Big_gcd(a As String, b As String) As String '最大公因數
    Return If(b = 0, a, Big_gcd(b, Big_Mod(a, b)))
End Function
~~~

##    浮點數二進位
根據IEEE-754的規定找出浮點數的值
```vb=
' 單精確 1bit符號位元 8bit指數位元 23bit小數位元
Public Class BinFloat
    Private _floatValue As Single

    Public Sub New()
        _floatValue = 0.0F
    End Sub

    Public Sub New(num As Single)
        _floatValue = num
    End Sub

    Public Sub SetFloat(num As Single)
        _floatValue = num
    End Sub

    Public Sub SetUnsigned(uintValue As UInteger)
        _floatValue = BitConverter.ToSingle(BitConverter.GetBytes(uintValue), 0)
    End Sub

    Public Function GetFloat() As Single
        Return _floatValue
    End Function

    Public Function GetUnsignedNum() As UInteger
        Return BitConverter.ToUInt32(BitConverter.GetBytes(_floatValue), 0)
    End Function

    Public Function GetBin() As String
        Dim uintValue As UInteger = GetUnsignedNum()
        Dim binary As Char() = New Char(31) {}
        For i As Integer = 0 To 31
            binary(31 - i) = Chr(&H30 + (uintValue And 1))
            uintValue >>= 1
        Next
        Return New String(binary)
    End Function
End Class
```

##    老鼠走迷宮
利用遞迴的方式找出終點
下面範例 2代表牆壁與邊界 1代表走過的路
~~~vb=
Private Sub Find_path(Optional ByVal x As Int16 = 1, Optional ByVal y As Int16 = 1, Optional ByRef f As Boolean = False)
    If f OrElse aaa(y, x) = 2 OrElse aaa(y, x) = 1 Then Exit Sub '牆壁與走過的路不走
    aaa(y, x) = 1
    If x = 5 AndAlso y = 5 Then '到終點結束
        f = True
        Exit Sub
    Else
        Find_path(x + 1, y, f) '嘗試往四周移動
        Find_path(x, y + 1, f)
        Find_path(x - 1, y, f)
        Find_path(x, y - 1, f)
    End If
End Sub
~~~

##    A ^ B mod C
求A的B次方MOD C

利用同餘定理計算
~~~vb=
Function ABmodC(a As Integer, b As Integer, c As Integer) As Int32
    Dim ans As Integer = 1
    a = a Mod c
    While b <> 0
        If (b And 1) = 1 Then
            ans = (ans * a) Mod c
        End If
        a = (a * a) Mod c
        b >>= 1
    End While
    Return ans
End Function
~~~

##    Permutation(排列)
找尋下一個排列數
回傳True代表arr已經變換成下一個排列數
回傳False代表已經是最後一個排列數
~~~vb=
Function next_permutation(ByRef arr() As Int32, ByVal lef As Int32, ByVal rig As Int32) As Boolean
    For i As Int32 = rig - 1 To lef + 1 Step -1
        If arr(i) > arr(i - 1) Then
            Dim j As Int32 = rig - 1
            While arr(i - 1) > arr(j)
                j -= 1
            End While
            Dim bufer As Int32 = arr(j)
            arr(j) = arr(i - 1)
            arr(i - 1) = bufer
            Array.Reverse(arr, i, rig - i)
            Return True
        End If
    Next
    Return False
End Function
~~~

範例輸出\
![](https://hackmd.io/_uploads/Hy1RLYwj2.png)


##    河內塔

~~~vb=
Private Sub ower_of_Hanoi(num As Int16, Optional A As Char = "A"c, Optional B As Char = "B"c, Optional C As Char = "C"c)
    If num = 1 Then
        Console.WriteLine("{0} ==> {1}", A, C)
    Else
        ower_of_Hanoi(num - 1, A, C, B)
        ower_of_Hanoi(1, A, B, C)
        ower_of_Hanoi(num - 1, B, A, C)
    End If
End Sub
~~~
範例輸出\
![](https://hackmd.io/_uploads/BJj_rKvj2.png)


##    8皇后
八皇后問題是一個以西洋棋為背景的問題：如何能夠在8×8的西洋棋棋盤上放置八個皇后，使得任何一個皇后都無法直接吃掉其他的皇后？為了達到此目的，任兩個皇后都不能處於同一條橫行、縱行或斜線上。八皇后問題可以推廣為更一般的n皇后擺放問題：這時棋盤的大小變為n×n，而皇后個數也變成n。
~~~vb=
Const N As Int16 = 8
Dim arr As New List(Of Int16()) '記錄所有解

Private Function IsVisitable(i As Int16, j As Int16, column() As Boolean, slash() As Boolean, backSlash() As Boolean) As Boolean '符合規則
    Return Not (column(j) OrElse slash(i + j) OrElse backSlash(i - j + N))
End Function

Private Sub BackTrack(column() As Boolean, slash() As Boolean, backSlash() As Boolean, queen() As Int16, Optional i As Int16 = 0)
    If i >= N Then '其中一個解
        arr.Add(queen.Clone)
    Else
        For j As Int16 = 0 To N - 1
            If IsVisitable(i, j, column, slash, backSlash) Then
                column(j) = True
                slash(i + j) = True
                backSlash(i - j + N) = True
                queen(i) = j
                BackTrack(column, slash, backSlash, queen, i + 1)
                column(j) = False
                slash(i + j) = False
                backSlash(i - j + N) = False
            End If
        Next
    End If
End Sub
~~~
##    背包問題

有一個背包與一些物品，背包有負重上限，每個物品都有重量，與價值，要如何放入最多價值的物品。  
這是一個動態規劃的經典問題。  
動態規劃的核心想法是把大問題拆成小問題，並儲存小問題的結果，而且小問題與大問題有所相關，最後集合小問題的結果求出大問題。  
作法如下
1. 先設一個陣列存放各個重量下的最大值
2. 對每個物品做判斷如果扣掉他的重量的最大值加上自己的價值超過現在的最大值則更新陣列

背包問題的核心演算法
~~~vb=
' map 儲存各個重量下的最大價值與組成最大值的物品(size = 負重上限)
' item 儲存各個物品的重量與價值
For Each it In items '遍歷所有物品
    For mapweight = map.Length - 1 To 0 Step -1
        If it.Weight > mapweight Then '負重大於上限
            Exit For
        End If
        '如果減去此物品重量的價值將上此物品的價值 > 現在的價值
        If map(mapweight - it.Weight) + it.Value > map(mapweight) Then
            map(mapweight) = map(mapweight - it.Weight) + it.Value '更新map
            'map(mapweight).ItemList = New List(Of Item)(map(mapweight - it.Weight).ItemList) From {it} '組成最大值的物品
        End If
    Next
Next
~~~

##    最短路徑

![image](https://d1dwq032kyr03c.cloudfront.net/upload/images/20181113/20111557WZr1y0kmdk.png)


這是一個有向無環圖我們要尋找從節點1到各個節點的最短路徑\
![Clipboarder.2024.09.05-008](https://hackmd.io/_uploads/SJTdiALn0.jpg)
1. 首先我們先除了起點以外的所有點的最短路徑都先設為infinity
2. 找目前最短的路徑0(代表從節點1到節點1的最短路徑為0)更新節點的路徑(節點1可到節點2、3)
3. 找目前最短的路徑1(代表從節點1到節點2的最短路徑為1)更新節點的路徑(節點2可到節點3、4)
5. 找目前最短的路徑4(代表從節點1到節點4的最短路徑為4)更新節點的路徑(節點4可到節點3、5、6)
6. 找目前最短的路徑8(代表從節點1到節點3的最短路徑為8)更新節點的路徑(節點3可到節點5)
7. 找目前最短的路徑13(代表從節點1到節點5的最短路徑為13)更新節點的路徑(節點5可到節點6)
8. 找目前最短的路徑19(代表從節點1到節點6的最短路徑為19)更新節點的路徑(節點6沒有下一個節點)


| 起點 | 終點 | 最短路徑 | 路線        |
|:----:|:----:|:--------:| ----------- |
|  1   |  1   |    0     | -           |
|  1   |  2   |    1     | 1-2         |
|  1   |  3   |    8     | 1-2-4-3     |
|  1   |  4   |    4     | 1-2-4       |
|  1   |  5   |    13    | 1-2-4-3-5   |
|  1   |  6   |    17    | 1-2-4-3-5-6 |

**作法:**\
尋找最短路徑這裡用的是廣度優先搜尋法，簡單說就是每一次都將所有種可能放進佇列中，每一次都找佇列中最小值(其實就是優先佇列)，走過的不再走，第一的碰到終點的解就是最短路徑。

###    固定權重(迷宮問題)

在迷宮中不管你往上下左右走距離都一樣，所以我們可以省略尋找最小距離的步驟，每次都取佇列的頭必是目前的最短路徑。\
例如說這裡有一個盤面我們要找到最短路徑\
![image](https://hackmd.io/_uploads/r13n8yP20.png)

1. 從起點開始往四周走(走過的不再走)
2. 將所有可能放進佇列中
3. 碰到終點的第一條路就是最短路徑


核心程式碼
~~~vb=
'MyPoint 自訂結構儲存點座標及路徑
Private Structure MyPoint
    Dim X, Y As Int16 '儲存座標
    Dim path As List(Of Char) '儲存走過的路徑
    Sub New(Optional x_ As Int16 = -1, Optional y_ As Int16 = -1, Optional path_ As List(Of Char) = Nothing) '建構式
        X = x_ : Y = y_
        path = If(path_ Is Nothing, New List(Of Char), New List(Of Char)(path_))
    End Sub
    Shared Operator =(a As MyPoint, b As MyPoint) As Boolean '多載 = 運算子方便實作(不一定要) 
        Return a.X = b.X AndAlso a.Y = b.Y
    End Operator
    Shared Operator <>(a As MyPoint, b As MyPoint) As Boolean 'VB = 與 <> 要同時多載
        Return Not a = b
    End Operator
End Structure

'mspoint 目前的位置，terminal_point 終點的位置
Dim nowpoint, terminal_point As New MyPoint
While nowpoint <> terminal_point
    flag(nowpoint.Y, nowpoint.X) = True '走過的點不再走
    If nowpoint.X + 1 <= boardSize AndAlso Not flag(nowpoint.Y, nowpoint.X + 1) Then '右方是否可走
        myqueue.Enqueue(New MyPoint(nowpoint.X + 1, nowpoint.Y, nowpoint.path)) '加入佇列
        myqueue.Last.path.Add("D"c)
    End If
    If nowpoint.Y + 1 <= boardSize AndAlso Not flag(nowpoint.Y + 1, nowpoint.X) Then '下方是否可走
        myqueue.Enqueue(New MyPoint(nowpoint.X, nowpoint.Y + 1, nowpoint.path)) '加入佇列
        myqueue.Last.path.Add("S"c)
    End If
    If nowpoint.X - 1 >= 0 AndAlso Not flag(nowpoint.Y, nowpoint.X - 1) Then '左方是否可走
        myqueue.Enqueue(New MyPoint(nowpoint.X - 1, nowpoint.Y, nowpoint.path)) '加入佇列
        myqueue.Last.path.Add("A"c)
    End If
    If nowpoint.Y - 1 >= 0 AndAlso Not flag(nowpoint.Y - 1, nowpoint.X) Then '上方是否可走
        myqueue.Enqueue(New MyPoint(nowpoint.X, nowpoint.Y - 1, nowpoint.path)) '加入佇列
        myqueue.Last.path.Add("W"c)
    End If
    While flag(nowpoint.Y, nowpoint.X) '走過的點不再走
        If myqueue.Count = 0 Then '當佇列為空 無路徑到終點
            fail = True
            Exit While
        End If
        nowpoint = myqueue.Dequeue '每次都走最短路徑
    End While
    If fail Then
        Exit While
    End If
End While
~~~

結果\
![image](https://hackmd.io/_uploads/Skt681w30.png)

###    權重不同

因為VB.net中沒有優先佇列，所以我們改用List搭配sort來模擬優先佇列方法如下:  
1. 從起點開始往四周走(走過的不再走)
2. 將所有可能放進List中
3. 排序(模擬優先佇列)
4. 只取第一筆資料(走最短路徑)
5. 重複第2步直到碰到終點的第一條路就是最短路徑

~~~vb=
Public Structure MyPoint
    Implements IComparable(Of MyPoint)
    Dim sum As Double '總路徑
    Dim now ,back As Int16 '現在的位置、從哪來
    Public Function CompareTo(other As MyPoint) As Integer Implements IComparable(Of MyPoint).CompareTo '自訂比較函數
        Return sum - other.sum
    End Function
End Structure

Sub Main()
    Dim Priority_Queue As New List(Of MyPoint) '模擬優先佇列
    Dim Now_Point, buffer As MyPoint
    Dim n, Start_Location, End_Location, Now_Location, back() As Int16
    Dim map(), flag As Boolean
    Dim data(,) As Double
        Do
        map(Now_Location) = True '走過的不再走
        For i As Int16 = 0 To n
            If Not map(i) AndAlso data(Now_Location, i) > 0 Then '放入所有可能
                buffer = Now_Point
                buffer.now = i
                buffer.back = Now_Location
                buffer.sum += data(Now_Location, i)
                Priority_Queue.Add(buffer)
            End If
        Next
        While map(Now_Location)
            If Priority_Queue.Count = 0 Then
                flag = True
                Exit While
            End If
            Priority_Queue.Sort() '用排序模擬優先佇列
            Now_Point = Priority_Queue.First '每次都走最短路徑
            Priority_Queue.Remove(Priority_Queue.First)
            If Not map(Now_Point.now) Then back(Now_Point.now) = Now_Point.back '走過的不再走
            Now_Location = Now_Point.now
        End While
        If flag Then Exit Do
    Loop While (Now_Location <> End_Location)
End Sub

~~~
[範例程式](https://drive.google.com/file/d/1-cdDDNDAJprUgnWf4bstIL-naWyJ7U7H/view?usp=sharing)

###    列印路徑

我們已經知道了兩個節點之間的最短路徑，那要如何知道這最短路徑會通過那些節點呢?\
![image](https://d1dwq032kyr03c.cloudfront.net/upload/images/20181113/20111557WZr1y0kmdk.png)\
透過上面的演算法我們可以得到從起點到對應節點的最短路徑，如下表。
| 起點 | 終點 | 最短路徑 |
|:----:|:----:|:--------:|
|  1   |  1   |    0     |
|  1   |  2   |    1     |
|  1   |  3   |    8     |
|  1   |  4   |    4     |
|  1   |  5   |    13    |
|  1   |  6   |    17    |

現在我們要找從節點1到節點6的最短路徑經過哪些節點?\
我們知道只有節點4和節點5可以到節點6。\
我們將到節點6的最短路徑減去到節點4的最短路徑，會得到2，這跟到4的最短路徑不相符，表示4到6不會是最短路徑所通過的節點。\
我們再將節點6的最短路徑減去到節點5的最短路徑，會得到13，這跟到5的最短路徑相符，表示5到6是最短路徑會通過的節點。\
重複上列的方法我們就可以找出節點1到節點6的最短路徑經過1-2-4-3-5-6\
==**因為科賽要比速度，所以我的作法是在計算最短路徑的過程中就把次移動的路徑記錄下來，當找到最短路徑時也可以直接輸出路徑。**==
##    前序、中序、後序
中序式就是我們平常習慣的表示法，像： 6 + 5 * 3 - 4 - 8 + 6 * 2\
那要如何轉換成前序及後序呢?\
這很簡單只要先將原算是加上括弧(每兩個數字及一個運算子一組)\
 ((((6 + (5 * 3)) - 4) - 8) + (6 * 2))\
 之後只要將運算子移至括弧前就是前序，移到括弧後就是後序。
| 前序 | 中序 | 後序 |
| -------- | -------- | -------- |
| + - - + 6 * 5 3 4 8 * 6 2    | 6+5\*3-4-8+6\*2     | 6 5 3 * + 4 - 8 - 6 2 * +   |
 
 後序演算法：\
 首先我們要先將運算子排優先度

| 優先度  | 運算子 |
| ------- |:------:|
| 3(最高) |   )    |
| 2       | * / %  |
| 1       |  + -   |
| 0 (最低)      |   (    |

1. 從算式最左邊開始當遇到數字直接輸出，遇到運算子放進堆疊中
2. 是"("直接放入堆疊，是")"彈出堆疊中的運算子直到碰到"("。其他的運算子放進堆疊時與堆疊最上方的運算子比較優先度
3. 若堆疊頂的優先度==大於等於==要放進去的運算子則將堆疊頂的運算子彈出，並重複2。否則將運算子放入堆疊
4. 當讀取完算式依序將堆疊中的運算子彈出

前序的演算法：\
=="("與")"的優先度與後序相==
1. 從算式最==右邊==開始當遇到數字直接輸出，遇到運算子放進堆疊中
2. ==是")"直接放入堆疊，是"("彈出堆疊中的運算子直到碰到")"==。其他的運算子放進堆疊時與堆疊最上方的運算子比較優先度
3. 若堆疊頂的優先度==大於==要放進去的運算子則將堆疊頂的運算子彈出，並重複2。否則將運算子放入堆疊
4. 當讀取完算式依序將堆疊中的運算子彈出
5. 最後將結果反轉

```vb=
Namespace Expression
    Module Expression
        Enum ExpressionMode
            PREFIX
            POSTFIX
        End Enum
        '比較優先度
        Function getOperatorPriority(op As Char, Optional mode As ExpressionMode = ExpressionMode.POSTFIX) As Integer
            If op = "("c Then
                Return If(mode = ExpressionMode.POSTFIX, 0, 3)
            ElseIf op = "+"c OrElse op = "-"c Then
                Return 1
            ElseIf op = "*"c OrElse op = "/"c OrElse op = "%"c Then
                Return 2
            ElseIf op = ")"c Then
                Return If(mode = ExpressionMode.POSTFIX, 3, 0)
            End If
            Return -1
        End Function
        '後序
        Function PostFix(expression As String()) As String
            Dim post = ""
            Dim opstack = New Stack(Of Char)
            For Each op In expression
                If IsNumeric(op) Then '數字直接輸出
                    post += op + " "
                ElseIf getOperatorPriority(op) = -1 Then
                    Continue For
                ElseIf getOperatorPriority(op) = 3 Then ') 特判
                    While opstack.Count <> 0 AndAlso getOperatorPriority(opstack.Peek) <> 0
                        post += opstack.Pop() + " "
                    End While
                    opstack.Pop()
                ElseIf getOperatorPriority(op) = 0 Then '( 直接放入堆疊
                    opstack.Push(op)
                Else
                    '比較優先度
                    While opstack.Count <> 0 AndAlso getOperatorPriority(opstack.Peek) >= getOperatorPriority(op)
                        post += opstack.Pop() + " "
                    End While
                    opstack.Push(op)
                End If
            Next
            While opstack.Count <> 0
                post += opstack.Pop() + " "
            End While
            Return post.TrimEnd(" "c)
        End Function

        '前序
        Function PreFix(expression As String()) As String
            Dim pre = ""
            Dim opstack = New Stack(Of Char)
            For Each op In expression.Reverse
                If IsNumeric(op) Then '數字直接輸出
                    pre += op + " "
                ElseIf getOperatorPriority(op, ExpressionMode.PREFIX) = -1 Then
                    Continue For
                ElseIf getOperatorPriority(op, ExpressionMode.PREFIX) = 3 Then '( 特判
                    While opstack.Count <> 0 AndAlso getOperatorPriority(opstack.Peek, ExpressionMode.PREFIX) <> 0
                        pre += opstack.Pop() + " "
                    End While
                    opstack.Pop()
                ElseIf getOperatorPriority(op, ExpressionMode.PREFIX) = 0 Then ') 直接放入堆疊
                    opstack.Push(op)
                Else
                    '比較優先度
                    While opstack.Count <> 0 AndAlso getOperatorPriority(opstack.Peek, ExpressionMode.PREFIX) > getOperatorPriority(op, ExpressionMode.PREFIX)
                        pre += opstack.Pop() + " "
                    End While
                    opstack.Push(op)
                End If
            Next
            While opstack.Count <> 0
                pre += opstack.Pop() + " "
            End While
            Return Strings.StrReverse(pre.TrimEnd(" "c))
        End Function
    End Module
End Namespace
```

##    Sort

排序在資訊科學中扮演著極為關鍵的角色，它是一種將一組資料按照特定順序排列的過程。看似簡單的排序，卻在許多應用場景中發揮著不可或缺的作用。\
下面列出了幾種常用的排序法提供參考(使用C++)\
==比賽時全部用Array.Sort()或所使用的容器提供的排序函數就好不要搞自己==


###    Bubble Sort
時間複雜度 O(n^2)
~~~cpp=
template<class T ,class CMP>
void Bubble_Sort(T* const first, T* const last, CMP cmp_) {
	for (T* i = first; i < last - 1; ++i) {
		for (T* j = i + 1; j < last; ++j) {
			if (cmp_(*i, *j)) {
				std::swap(*i, *j);
			}
		}
	}
}
~~~
###    Selection Sort
時間複雜度 O(n^2)
```cpp=
template<typename T, typename CMP>
inline void Selection_Sort(T* first_, T* last_, CMP cmp_)
{
	for (T* i = first_ ;i < last_ - 1; ++i)
	{
		T* buffer = i;
		for (T* j = i + 1; j < last_; ++j)
		{
			if (cmp_(*buffer, *j))
			{
				buffer = j;
			}
		}
		if (*i != *buffer)
		{
			std::swap(*i, *buffer);
		}
	}
}
```

###    Quick Sort
1. 從左到右找比基準值大的數
2. 從右到左找比基準值小的數
3. 若右的索引值大於左交換
4. 重複1-3直到交叉
5. 基準與右交換
6. 分成左右遞迴

快速排序是一種有效的排序演算法，它透過遞歸地將輸入數組劃分為更小的子數組來工作。它是最常用的排序演算法之一，因為其==平均時間複雜度為 O(n log n)==，其中 n 是數組中元素的數量。
~~~cpp=
template<typename T, typename  CMP>
inline void Quicksrot(T* first_, T* last_, CMP cmp_)
{
	T *i, *j;
	if (first_ < last_)
	{
		i = first_;
		j = last_ ;
		do
		{
			do
			{
				++i;
			} while (i < last_ && cmp_(*first_, *i));
			do
			{
				--j;
			} while (cmp_(*j, *first_));
			if (i < j)
			{
				std::swap(*i, *j);
			}
                       else break;
		} while (1);
		std::swap(*first_, *j);
		Quicksrot(first_, j , cmp_);
		Quicksrot(j+1, last_, cmp_);
	}
}
~~~
###    Tim Sort
Timsort 是一種混合排序演算法，它結合了插入排序和合并排序的優點。Timsort 的==時間複雜度為 O(n log n)==，平均情況下，其效率比冒泡排序、插入排序、選擇排序等排序演算法要高。

####    Timsort 的步驟如下：

1. 將陣列分為短的子陣列，每個子陣列的大小小於 32。
2. 對每個短的子陣列使用插入排序進行排序。
3. 將排序好的短的子陣列合并在一起，形成一個大的子陣列。
4. 對大的子陣列使用合并排序進行排序。
####    Timsort 的優點是：

1. 效率高、穩定性好
2. 最壞情況時間複雜度為 O(n log n)
####    Timsort 的具體工作原理如下：

Timsort 首先將陣列分為短的子陣列，每個子陣列的大小小於 32。然後，對每個短的子陣列使用插入排序進行排序。插入排序是一種穩定的排序演算法，它可以保證相同的元素在排序後保持原來的相對位置。

將短的子陣列排序後，Timsort 將它們合并在一起，形成一個大的子陣列。然後，對大的子陣列使用合并排序進行排序。合并排序是一種高效的排序演算法，它可以將兩個已排序的子陣列合并為一個大的已排序的子陣列。

####    Timsort 採用了以下技術來提高效率：

使用插入排序對短的子陣列進行排序，可以提高效率，尤其是當子陣列的大小較小時。
使用合并排序對大的子陣列進行排序，可以提高效率，尤其是當子陣列的大小較大時。
使用了一種特殊的算法來合并已排序的子陣列，可以提高效率。
Timsort 是一種比較好的排序演算法。它適合於各種數據集的排序，尤其是數據集的隨機排序。

####    實作範例
~~~cpp=
constexpr int RUN = 32;

// This function sorts array from left
// index to to right index which is
// of size atmost RUN
inline void insertionSort(int arr[],const int& left,const int& right)
{
    for (int i = left + 1; i <= right; i++) {
        int temp = arr[i];
        int j = i - 1;
        while (j >= left && arr[j] > temp) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = temp;
    }
}

// Merge function merges the sorted runs
inline void merge(int arr[],const int& l,const int& m,const int& r)
{

    // Original array is broken in two
    // parts left and right array
    int&& len1 = m - l + 1, && len2 = r - m;
    //int left[len1], right[len2];
    int* left = new int[len1];
    int* right = new int[len2];
    for (int i = 0; i < len1; i++)
        left[i] = arr[l + i];
    for (int i = 0; i < len2; i++)
        right[i] = arr[m + 1 + i];

    int i = 0;
    int j = 0;
    int k = l;

    // After comparing, we
    // merge those two array
    // in larger sub array
    while (i < len1 && j < len2) {
        if (left[i] <= right[j]) {
            arr[k] = left[i];
            i++;
        }
        else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of
    // left, if any
    while (i < len1) {
        arr[k] = left[i];
        k++;
        i++;
    }

    // Copy remaining element of
    // right, if any
    while (j < len2) {
        arr[k] = right[j];
        k++;
        j++;
    }
}

// Iterative Timsort function to sort the
// array[0...n-1] (similar to merge sort)
inline void timSort(int arr[], const int& n)
{

    // Sort individual subarrays of size RUN
    for (int i = 0; i < n; i += RUN)
        insertionSort(arr, i, min((i + RUN - 1), (n - 1)));

    // Start merging from size RUN (or 32).
    // It will merge
    // to form size 64, then 128, 256
    // and so on ....
    for (int size = RUN; size < n; size = 2 * size) {

        // pick starting point of
        // left sub array. We
        // are going to merge
        // arr[left..left+size-1]
        // and arr[left+size, left+2*size-1]
        // After every merge, we
        // increase left by 2*size
        for (int left = 0; left < n; left += 2 * size) {

            // Find ending point of
            // left sub array
            // mid+1 is starting point
            // of right sub array
            int mid = left + size - 1;
            int right = min((left + 2 * size - 1), (n - 1));

            // merge sub array arr[left.....mid] &
            // arr[mid+1....right]
            if (mid < right)
                merge(arr, left, mid, right);
        }
    }
}
~~~



#    資料結構

資料結構意味著介面或封裝：一個資料結構可被視為兩個函數之間的介面，或者是由資料類型聯合組成的儲存內容的訪問方法封裝。

大多數資料結構都由數列、記錄、可辨識聯合、參照等基本類型構成。舉例而言，可為空的參照（nullable reference）是參照與可辨識聯合的結合體，而最簡單的鏈式結構鏈結串列則是由記錄與可空參照構成。

資料結構可透過程式語言所提供的資料類型、參照及其他操作加以實現。一個設計良好的資料結構，應該在儘可能使用較少的時間與空間資源的前提下，支援各種程式執行。

不同種類的資料結構適合不同種類的應用，部分資料結構甚至是為了解決特定問題而設計出來的。例如B樹即為加快樹狀結構存取速度而設計的資料結構，常被應用在資料庫和檔案系統上。

正確的資料結構選擇可以提高演算法的效率（請參考演算法效率）。在電腦程式設計的過程中，選擇適當的資料結構是一項重要工作。許多大型系統的編寫經驗顯示，程式設計的困難程度與最終成果的品質與表現，取決於是否選擇了最適合的資料結構。

==~~工科賽都用不到 看過就好~~==\
==除非有必要不然都可以直接用現成的容器==

**由於空間問題詳細內容放於這裡==> [資料結構](https://hackmd.io/@guoQnpNWTySbqlkqsBPSyA/rkm2MFjfJl)**
#    問題回報

**若發現內容有錯誤、或是有問題(不限於程式)都能用下面聯絡方式找我們**  
建議聯絡時間(8:00AM ~ 1:00AM )  
你也可以求助主任~~相信他會有辦法找到我們的~~  
~~但除非很急不然請不要半夜call我們~~

##    Gmail
> willy050209@gmail.com

##    DC
> username : .chenyuwei

##    LINE
> [點我](https://line.me/ti/p/xtC_1nBiss)

#    Contributor
:::success
**優秀的瑞芳高工資訊科校友們**
:::
在瑞芳高工資訊科的歷史長河中，一代又一代的校友用自己的努力與才華，為母校增添光彩。他們不僅在學期間積極學習專業技能，更在畢業後於各行各業中發光發熱，成為母校最引以為傲的名片。在此，我們懷著無比感恩的心，向所有瑞芳高工資訊科的校友們致以最誠摯的謝意。

在這個快速變化的時代，資訊科技已成為推動社會進步的重要引擎。而瑞芳高工資訊科的校友們，正是這個時代不可或缺的先行者。他們在學術研究、科技產業、創業領域甚至其他多元化的職業中，發揮了自己的專業所長。校友們的成就不僅是個人的榮耀，更是母校辦學成果的最佳見證。

校友的回饋與支持也為學弟妹們提供了寶貴的資源與指引。不論是校友回校分享經驗，還是提供自己的技巧，並與大家一同完成這份選手筆記，都為在校生的學習與成長注入了新的動力。你們的無私付出讓我們深深感受到，校友與母校之間的聯繫是如此緊密。

再次感謝瑞芳高工資訊科的每一位校友，因為有你們，母校的未來更加充滿希望。願你們在各自的人生道路上繼續攀登高峰，也願我們攜手共創更美好的明天，更祝福現在正在努力的選手你們定能奪取金手獎。

#    夾帶私貨
在準備工科賽的過程中，精湛的演算法、熟練的程式語言能力固然重要，但往往被忽略的是一個關鍵因素：休息。你可能認為，程式競賽就是一場無止境的腦力激盪，只要不斷地刷題、練習，就能取得好成績。然而，事實並非如此。適時的休息，不僅能讓身心得到放鬆，更能提高解題效率，進而提升競賽成績。\
~~絕對不是想要推銷自己的推~~\
休息對於程式競賽的影響不可忽視。它不僅僅是為了恢復體力，更是提升專注力、創意思維、學習效率以及心理健康的關鍵。在努力提升實力的同時，選手也應該為自己的身心健康負責，養成良好的休息習慣，才能在程式競賽中持續進步並取得優異成績。\
所以下列整理了一些適合在休息時觀看的頻道\
~~真的不是想要推銷自己的推~~

[森森鈴蘭Lily Linglan](https://lit.link/en/lilylinglan)\
![image alt](https://prd.storage.lit.link/images/creators/a9418eaf-253c-475a-9a93-05b15a3f169b/3d48003c-4150-4962-9103-22c5a95cc9a3.jpg)

[瑪格麗特 · 諾爾絲 / Margaret North](https://www.youtube.com/@margaretnorth)\
![image alt](https://images.ams-prd.blv.cloud/eyJidWNrZXQiOiJpbWFnZXMtcHJkLTFvNHV6OXpieHd6cDF1Ym0iLCJrZXkiOiI1ZmZjNzMyNi1mOTY4LTQ0YWQtOWU2Yi02Nzg4NGM1MjhlMDgiLCJlZGl0cyI6eyJyZXNpemUiOnsid2lkdGgiOjM2MCwiaGVpZ2h0IjozNjB9fX0)

[杏仁ミル](https://www.youtube.com/@AnninMiru)\
![image alt](https://pbs.twimg.com/profile_images/1667479870409158656/OlnFjlxm_400x400.jpg)

[周防パトラ](https://ptrsuou.com/)\
![image alt](https://pbs.twimg.com/profile_images/1836225613553897472/Fvhr0wQ6_400x400.jpg)

[飴宮なずな](https://www.twitch.tv/amemiyanazuna)\
![image alt](https://pbs.twimg.com/profile_images/1663599879464292353/jEw6805c_400x400.jpg)

[みけねこねここ](https://www.twitch.tv/nekoko88)\
![image alt](https://pbs.twimg.com/profile_images/1682758052934742016/H5G2kV0O_400x400.jpg)